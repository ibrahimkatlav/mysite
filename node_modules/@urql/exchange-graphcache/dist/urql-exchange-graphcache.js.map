{"version":3,"file":"urql-exchange-graphcache.js","sources":["../src/helpers/help.ts","../src/ast/node.ts","../src/ast/variables.ts","../src/ast/traversal.ts","../src/ast/schema.ts","../src/ast/schemaPredicates.ts","../src/store/keys.ts","../src/store/data.ts","../src/operations/shared.ts","../src/operations/query.ts","../src/operations/invalidate.ts","../src/operations/write.ts","../src/store/store.ts","../src/helpers/operation.ts","../src/cacheExchange.ts","../src/offlineExchange.ts"],"sourcesContent":["// These are guards that are used throughout the codebase to warn or error on\n// unexpected behaviour or conditions.\n// Every warning and error comes with a number that uniquely identifies them.\n// You can read more about the messages themselves in `docs/graphcache/errors.md`\n\nimport type {\n  ExecutableDefinitionNode,\n  InlineFragmentNode,\n} from '@0no-co/graphql.web';\nimport type { Logger } from '../types';\nimport { Kind } from '@0no-co/graphql.web';\n\nexport type ErrorCode =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28;\n\ntype DebugNode = ExecutableDefinitionNode | InlineFragmentNode;\n\n// URL unfurls to https://formidable.com/open-source/urql/docs/graphcache/errors/\nconst helpUrl = '\\nhttps://bit.ly/2XbVrpR#';\nconst cache = new Set<string>();\n\nexport const currentDebugStack: string[] = [];\n\nexport const popDebugNode = () => currentDebugStack.pop();\n\nexport const pushDebugNode = (typename: void | string, node: DebugNode) => {\n  let identifier = '';\n  if (node.kind === Kind.INLINE_FRAGMENT) {\n    identifier = typename\n      ? `Inline Fragment on \"${typename}\"`\n      : 'Inline Fragment';\n  } else if (node.kind === Kind.OPERATION_DEFINITION) {\n    const name = node.name ? `\"${node.name.value}\"` : 'Unnamed';\n    identifier = `${name} ${node.operation}`;\n  } else if (node.kind === Kind.FRAGMENT_DEFINITION) {\n    identifier = `\"${node.name.value}\" Fragment`;\n  }\n\n  if (identifier) {\n    currentDebugStack.push(identifier);\n  }\n};\n\nconst getDebugOutput = (): string =>\n  currentDebugStack.length\n    ? '\\n(Caused At: ' + currentDebugStack.join(', ') + ')'\n    : '';\n\nexport function invariant(\n  condition: any,\n  message: string,\n  code: ErrorCode\n): asserts condition {\n  if (!condition) {\n    let errorMessage = message || 'Minfied Error #' + code + '\\n';\n    if (process.env.NODE_ENV !== 'production') {\n      errorMessage += getDebugOutput();\n    }\n\n    const error = new Error(errorMessage + helpUrl + code);\n    error.name = 'Graphcache Error';\n    throw error;\n  }\n}\n\nexport function warn(\n  message: string,\n  code: ErrorCode,\n  logger: Logger | undefined\n) {\n  if (!cache.has(message)) {\n    if (logger) {\n      logger('warn', message + getDebugOutput() + helpUrl + code);\n    } else {\n      console.warn(message + getDebugOutput() + helpUrl + code);\n    }\n    cache.add(message);\n  }\n}\n","import type {\n  NamedTypeNode,\n  NameNode,\n  DirectiveNode,\n  SelectionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from '@0no-co/graphql.web';\n\nimport type { FormattedNode } from '@urql/core';\n\nexport type SelectionSet = readonly FormattedNode<SelectionNode>[];\n\nconst EMPTY_DIRECTIVES: Record<string, DirectiveNode | undefined> = {};\n\n/** Returns the directives dictionary of a given node */\nexport const getDirectives = (node: {\n  _directives?: Record<string, DirectiveNode | undefined>;\n}) => node._directives || EMPTY_DIRECTIVES;\n\n/** Returns the name of a given node */\nexport const getName = (node: { name: NameNode }): string => node.name.value;\n\nexport const getFragmentTypeName = (node: FragmentDefinitionNode): string =>\n  node.typeCondition.name.value;\n\n/** Returns either the field's name or the field's alias */\nexport const getFieldAlias = (node: FieldNode): string =>\n  node.alias ? node.alias.value : node.name.value;\n\nconst emptySelectionSet: SelectionSet = [];\n\n/** Returns the SelectionSet for a given inline or defined fragment node */\nexport const getSelectionSet = (node: {\n  selectionSet?: FormattedNode<SelectionSetNode>;\n}): FormattedNode<SelectionSet> =>\n  (node.selectionSet\n    ? node.selectionSet.selections\n    : emptySelectionSet) as FormattedNode<SelectionSet>;\n\nexport const getTypeCondition = (node: {\n  typeCondition?: NamedTypeNode;\n}): string | null =>\n  node.typeCondition ? node.typeCondition.name.value : null;\n","import type {\n  FieldNode,\n  DirectiveNode,\n  OperationDefinitionNode,\n} from '@0no-co/graphql.web';\nimport { valueFromASTUntyped } from '@0no-co/graphql.web';\n\nimport { getName } from './node';\n\nimport type { Variables } from '../types';\n\n/** Evaluates a fields arguments taking vars into account */\nexport const getFieldArguments = (\n  node: FieldNode | DirectiveNode,\n  vars: Variables\n): null | Variables => {\n  let args: null | Variables = null;\n  if (node.arguments) {\n    for (let i = 0, l = node.arguments.length; i < l; i++) {\n      const arg = node.arguments[i];\n      const value = valueFromASTUntyped(arg.value, vars);\n      if (value !== undefined && value !== null) {\n        if (!args) args = {};\n        args[getName(arg)] = value as any;\n      }\n    }\n  }\n  return args;\n};\n\n/** Returns a filtered form of variables with values missing that the query doesn't require */\nexport const filterVariables = (\n  node: OperationDefinitionNode,\n  input: void | object\n) => {\n  if (!input || !node.variableDefinitions) {\n    return undefined;\n  }\n\n  const vars = {};\n  for (let i = 0, l = node.variableDefinitions.length; i < l; i++) {\n    const name = getName(node.variableDefinitions[i].variable);\n    vars[name] = input[name];\n  }\n\n  return vars;\n};\n\n/** Returns a normalized form of variables with defaulted values */\nexport const normalizeVariables = (\n  node: OperationDefinitionNode,\n  input: void | Record<string, unknown>\n): Variables => {\n  const vars = {};\n  if (!input) return vars;\n\n  if (node.variableDefinitions) {\n    for (let i = 0, l = node.variableDefinitions.length; i < l; i++) {\n      const def = node.variableDefinitions[i];\n      const name = getName(def.variable);\n      vars[name] =\n        input[name] === undefined && def.defaultValue\n          ? valueFromASTUntyped(def.defaultValue, input)\n          : input[name];\n    }\n  }\n\n  for (const key in input) {\n    if (!(key in vars)) vars[key] = input[key];\n  }\n\n  return vars;\n};\n","import type {\n  SelectionNode,\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n} from '@0no-co/graphql.web';\nimport { valueFromASTUntyped, Kind } from '@0no-co/graphql.web';\n\nimport type { FormattedNode } from '@urql/core';\nimport { getName, getDirectives } from './node';\nimport { invariant } from '../helpers/help';\nimport type { Fragments, Variables } from '../types';\n\nfunction getMainOperation(\n  doc: FormattedNode<DocumentNode>\n): FormattedNode<OperationDefinitionNode>;\nfunction getMainOperation(doc: DocumentNode): OperationDefinitionNode;\n\n/** Returns the main operation's definition */\nfunction getMainOperation(doc: DocumentNode): OperationDefinitionNode {\n  for (let i = 0; i < doc.definitions.length; i++) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      return doc.definitions[i] as FormattedNode<OperationDefinitionNode>;\n    }\n  }\n\n  invariant(\n    false,\n    'Invalid GraphQL document: All GraphQL documents must contain an OperationDefinition' +\n      'node for a query, subscription, or mutation.',\n    1\n  );\n}\n\nexport { getMainOperation };\n\n/** Returns a mapping from fragment names to their selections */\nexport const getFragments = (doc: FormattedNode<DocumentNode>): Fragments => {\n  const fragments: Fragments = {};\n  for (let i = 0; i < doc.definitions.length; i++) {\n    const node = doc.definitions[i];\n    if (node.kind === Kind.FRAGMENT_DEFINITION) {\n      fragments[getName(node)] = node;\n    }\n  }\n\n  return fragments;\n};\n\n/** Resolves @include and @skip directives to determine whether field is included. */\nexport const shouldInclude = (\n  node: FormattedNode<SelectionNode>,\n  vars: Variables\n): boolean => {\n  const directives = getDirectives(node);\n  if (directives.include || directives.skip) {\n    // Finds any @include or @skip directive that forces the node to be skipped\n    for (const name in directives) {\n      const directive = directives[name];\n      if (\n        directive &&\n        (name === 'include' || name === 'skip') &&\n        directive.arguments &&\n        directive.arguments[0] &&\n        getName(directive.arguments[0]) === 'if'\n      ) {\n        // Return whether this directive forces us to skip\n        // `@include(if: false)` or `@skip(if: true)`\n        const value = valueFromASTUntyped(directive.arguments[0].value, vars);\n        return name === 'include' ? !!value : !value;\n      }\n    }\n  }\n  return true;\n};\n\n/** Resolves @defer directive to determine whether a fragment is potentially skipped. */\nexport const isDeferred = (\n  node: FormattedNode<FragmentSpreadNode | InlineFragmentNode>,\n  vars: Variables\n): boolean => {\n  const { defer } = getDirectives(node);\n  if (defer) {\n    for (const argument of defer.arguments || []) {\n      if (getName(argument) === 'if') {\n        // Return whether `@defer(if: )` is enabled\n        return !!valueFromASTUntyped(argument.value, vars);\n      }\n    }\n    return true;\n  }\n\n  return false;\n};\n\n/** Resolves @_optional and @_required directive to determine whether the fields in a fragment are conaidered optional. */\nexport const isOptional = (\n  node: FormattedNode<FragmentSpreadNode | InlineFragmentNode>\n): boolean | undefined => {\n  const { optional, required } = getDirectives(node);\n  if (required) {\n    return false;\n  }\n\n  if (optional) {\n    return true;\n  }\n\n  return undefined;\n};\n","import type {\n  IntrospectionQuery,\n  IntrospectionTypeRef,\n  IntrospectionInputValue,\n  IntrospectionType,\n} from './graphql';\n\nexport interface SchemaField {\n  name: string;\n  type: IntrospectionTypeRef;\n  args(): Record<string, IntrospectionInputValue | void>;\n}\n\nexport interface SchemaObject {\n  name: string;\n  kind: 'INTERFACE' | 'OBJECT';\n  interfaces(): Record<string, unknown>;\n  fields(): Record<string, SchemaField | void>;\n}\n\nexport interface SchemaUnion {\n  name: string;\n  kind: 'UNION';\n  types(): Record<string, unknown>;\n}\n\nexport interface SchemaIntrospector {\n  query: string | null;\n  mutation: string | null;\n  subscription: string | null;\n  types?: Map<string, SchemaObject | SchemaUnion>;\n  isSubType(abstract: string, possible: string): boolean;\n}\n\nexport interface PartialIntrospectionSchema {\n  queryType: { name: string; kind?: any };\n  mutationType?: { name: string; kind?: any } | null;\n  subscriptionType?: { name: string; kind?: any } | null;\n  types?: readonly any[];\n}\n\nexport type IntrospectionData =\n  | IntrospectionQuery\n  | { __schema: PartialIntrospectionSchema };\n\nexport const buildClientSchema = ({\n  __schema,\n}: IntrospectionData): SchemaIntrospector => {\n  const typemap: Map<string, SchemaObject | SchemaUnion> = new Map();\n\n  const buildNameMap = <T extends { name: string }>(\n    arr: ReadonlyArray<T>\n  ): (() => { [name: string]: T }) => {\n    let map: Record<string, T> | void;\n    return () => {\n      if (!map) {\n        map = {};\n        for (let i = 0; i < arr.length; i++) map[arr[i].name] = arr[i];\n      }\n      return map;\n    };\n  };\n\n  const buildType = (\n    type: IntrospectionType\n  ): SchemaObject | SchemaUnion | void => {\n    switch (type.kind) {\n      case 'OBJECT':\n      case 'INTERFACE':\n        return {\n          name: type.name,\n          kind: type.kind as 'OBJECT' | 'INTERFACE',\n          interfaces: buildNameMap(type.interfaces || []),\n          fields: buildNameMap(\n            type.fields!.map((field: any) => ({\n              name: field.name,\n              type: field.type,\n              args: buildNameMap(field.args),\n            }))\n          ),\n        } as SchemaObject;\n      case 'UNION':\n        return {\n          name: type.name,\n          kind: type.kind as 'UNION',\n          types: buildNameMap(type.possibleTypes || []),\n        } as SchemaUnion;\n    }\n  };\n\n  const schema: SchemaIntrospector = {\n    query: __schema.queryType ? __schema.queryType.name : null,\n    mutation: __schema.mutationType ? __schema.mutationType.name : null,\n    subscription: __schema.subscriptionType\n      ? __schema.subscriptionType.name\n      : null,\n    types: undefined,\n    isSubType(abstract: string, possible: string) {\n      const abstractType = typemap.get(abstract);\n      const possibleType = typemap.get(possible);\n      if (!abstractType || !possibleType) {\n        return false;\n      } else if (abstractType.kind === 'UNION') {\n        return !!abstractType.types()[possible];\n      } else if (\n        abstractType.kind !== 'OBJECT' &&\n        possibleType.kind === 'OBJECT'\n      ) {\n        return !!possibleType.interfaces()[abstract];\n      } else {\n        return abstract === possible;\n      }\n    },\n  };\n\n  if (__schema.types) {\n    schema.types = typemap;\n    for (let i = 0; i < __schema.types.length; i++) {\n      const type = __schema.types[i];\n      if (type && type.name) {\n        const out = buildType(type);\n        if (out) typemap.set(type.name, out);\n      }\n    }\n  }\n\n  return schema;\n};\n","import type {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from '@0no-co/graphql.web';\n\nimport { warn, invariant } from '../helpers/help';\nimport { getTypeCondition } from './node';\nimport type { SchemaIntrospector, SchemaObject } from './schema';\n\nimport type {\n  KeyingConfig,\n  UpdatesConfig,\n  ResolverConfig,\n  OptimisticMutationConfig,\n  Logger,\n} from '../types';\n\nconst BUILTIN_NAME = '__';\n\nexport const isFieldNullable = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string,\n  logger: Logger | undefined\n): boolean => {\n  const field = getField(schema, typename, fieldName, logger);\n  return !!field && field.type.kind !== 'NON_NULL';\n};\n\nexport const isListNullable = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string,\n  logger: Logger | undefined\n): boolean => {\n  const field = getField(schema, typename, fieldName, logger);\n  if (!field) return false;\n  const ofType =\n    field.type.kind === 'NON_NULL' ? field.type.ofType : field.type;\n  return ofType.kind === 'LIST' && ofType.ofType.kind !== 'NON_NULL';\n};\n\nexport const isFieldAvailableOnType = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string,\n  logger: Logger | undefined\n): boolean =>\n  fieldName.indexOf(BUILTIN_NAME) === 0 ||\n  typename.indexOf(BUILTIN_NAME) === 0 ||\n  !!getField(schema, typename, fieldName, logger);\n\nexport const isInterfaceOfType = (\n  schema: SchemaIntrospector,\n  node: InlineFragmentNode | FragmentDefinitionNode,\n  typename: string | void\n): boolean => {\n  if (!typename) return false;\n  const typeCondition = getTypeCondition(node);\n  if (!typeCondition || typename === typeCondition) {\n    return true;\n  } else if (\n    schema.types!.has(typeCondition) &&\n    schema.types!.get(typeCondition)!.kind === 'OBJECT'\n  ) {\n    return typeCondition === typename;\n  }\n\n  expectAbstractType(schema, typeCondition!);\n  expectObjectType(schema, typename!);\n  return schema.isSubType(typeCondition, typename);\n};\n\nconst getField = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string,\n  logger: Logger | undefined\n) => {\n  if (\n    fieldName.indexOf(BUILTIN_NAME) === 0 ||\n    typename.indexOf(BUILTIN_NAME) === 0\n  )\n    return;\n\n  expectObjectType(schema, typename);\n  const object = schema.types!.get(typename) as SchemaObject;\n  const field = object.fields()[fieldName];\n  if (!field) {\n    warn(\n      'Invalid field: The field `' +\n        fieldName +\n        '` does not exist on `' +\n        typename +\n        '`, ' +\n        'but the GraphQL document expects it to exist.\\n' +\n        'Traversal will continue, however this may lead to undefined behavior!',\n      4,\n      logger\n    );\n  }\n\n  return field;\n};\n\nfunction expectObjectType(schema: SchemaIntrospector, typename: string) {\n  invariant(\n    schema.types!.has(typename) &&\n      schema.types!.get(typename)!.kind === 'OBJECT',\n    'Invalid Object type: The type `' +\n      typename +\n      '` is not an object in the defined schema, ' +\n      'but the GraphQL document is traversing it.',\n    3\n  );\n}\n\nfunction expectAbstractType(schema: SchemaIntrospector, typename: string) {\n  invariant(\n    schema.types!.has(typename) &&\n      (schema.types!.get(typename)!.kind === 'INTERFACE' ||\n        schema.types!.get(typename)!.kind === 'UNION'),\n    'Invalid Abstract type: The type `' +\n      typename +\n      '` is not an Interface or Union type in the defined schema, ' +\n      'but a fragment in the GraphQL document is using it as a type condition.',\n    5\n  );\n}\n\nexport function expectValidKeyingConfig(\n  schema: SchemaIntrospector,\n  keys: KeyingConfig,\n  logger: Logger | undefined\n): void {\n  if (process.env.NODE_ENV !== 'production') {\n    for (const key in keys) {\n      if (!schema.types!.has(key)) {\n        warn(\n          'Invalid Object type: The type `' +\n            key +\n            '` is not an object in the defined schema, but the `keys` option is referencing it.',\n          20,\n          logger\n        );\n      }\n    }\n  }\n}\n\nexport function expectValidUpdatesConfig(\n  schema: SchemaIntrospector,\n  updates: UpdatesConfig,\n  logger: Logger | undefined\n): void {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  for (const typename in updates) {\n    if (!updates[typename]) {\n      continue;\n    } else if (!schema.types!.has(typename)) {\n      let addition = '';\n\n      if (\n        typename === 'Mutation' &&\n        schema.mutation &&\n        schema.mutation !== 'Mutation'\n      ) {\n        addition +=\n          '\\nMaybe your config should reference `' + schema.mutation + '`?';\n      } else if (\n        typename === 'Subscription' &&\n        schema.subscription &&\n        schema.subscription !== 'Subscription'\n      ) {\n        addition +=\n          '\\nMaybe your config should reference `' + schema.subscription + '`?';\n      }\n\n      return warn(\n        'Invalid updates type: The type `' +\n          typename +\n          '` is not an object in the defined schema, but the `updates` config is referencing it.' +\n          addition,\n        21,\n        logger\n      );\n    }\n\n    const fields = (schema.types!.get(typename)! as SchemaObject).fields();\n    for (const fieldName in updates[typename]!) {\n      if (!fields[fieldName]) {\n        warn(\n          'Invalid updates field: `' +\n            fieldName +\n            '` on `' +\n            typename +\n            '` is not in the defined schema, but the `updates` config is referencing it.',\n          22,\n          logger\n        );\n      }\n    }\n  }\n}\n\nfunction warnAboutResolver(name: string, logger: Logger | undefined): void {\n  warn(\n    `Invalid resolver: \\`${name}\\` is not in the defined schema, but the \\`resolvers\\` option is referencing it.`,\n    23,\n    logger\n  );\n}\n\nfunction warnAboutAbstractResolver(\n  name: string,\n  kind: 'UNION' | 'INTERFACE',\n  logger: Logger | undefined\n): void {\n  warn(\n    `Invalid resolver: \\`${name}\\` does not match to a concrete type in the schema, but the \\`resolvers\\` option is referencing it. Implement the resolver for the types that ${\n      kind === 'UNION' ? 'make up the union' : 'implement the interface'\n    } instead.`,\n    26,\n    logger\n  );\n}\n\nexport function expectValidResolversConfig(\n  schema: SchemaIntrospector,\n  resolvers: ResolverConfig,\n  logger: Logger | undefined\n): void {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  for (const key in resolvers) {\n    if (key === 'Query') {\n      if (schema.query) {\n        const validQueries = (\n          schema.types!.get(schema.query) as SchemaObject\n        ).fields();\n        for (const resolverQuery in resolvers.Query || {}) {\n          if (!validQueries[resolverQuery]) {\n            warnAboutResolver('Query.' + resolverQuery, logger);\n          }\n        }\n      } else {\n        warnAboutResolver('Query', logger);\n      }\n    } else {\n      if (!schema.types!.has(key)) {\n        warnAboutResolver(key, logger);\n      } else if (\n        schema.types!.get(key)!.kind === 'INTERFACE' ||\n        schema.types!.get(key)!.kind === 'UNION'\n      ) {\n        warnAboutAbstractResolver(\n          key,\n          schema.types!.get(key)!.kind as 'INTERFACE' | 'UNION',\n          logger\n        );\n      } else {\n        const validTypeProperties = (\n          schema.types!.get(key) as SchemaObject\n        ).fields();\n        for (const resolverProperty in resolvers[key] || {}) {\n          if (!validTypeProperties[resolverProperty]) {\n            warnAboutResolver(key + '.' + resolverProperty, logger);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport function expectValidOptimisticMutationsConfig(\n  schema: SchemaIntrospector,\n  optimisticMutations: OptimisticMutationConfig,\n  logger: Logger | undefined\n): void {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  if (schema.mutation) {\n    const validMutations = (\n      schema.types!.get(schema.mutation) as SchemaObject\n    ).fields();\n    for (const mutation in optimisticMutations) {\n      if (!validMutations[mutation]) {\n        warn(\n          `Invalid optimistic mutation field: \\`${mutation}\\` is not a mutation field in the defined schema, but the \\`optimistic\\` option is referencing it.`,\n          24,\n          logger\n        );\n      }\n    }\n  }\n}\n","import { stringifyVariables } from '@urql/core';\nimport type { FieldArgs, FieldInfo, KeyInfo } from '../types';\n\nexport const keyOfField = (fieldName: string, args?: FieldArgs) =>\n  args ? `${fieldName}(${stringifyVariables(args)})` : fieldName;\n\nexport const joinKeys = (parentKey: string, key: string) =>\n  `${parentKey}.${key}`;\n\nexport const fieldInfoOfKey = (fieldKey: string): FieldInfo => {\n  const parenIndex = fieldKey.indexOf('(');\n  if (parenIndex > -1) {\n    return {\n      fieldKey,\n      fieldName: fieldKey.slice(0, parenIndex),\n      arguments: JSON.parse(fieldKey.slice(parenIndex + 1, -1)),\n    };\n  } else {\n    return {\n      fieldKey,\n      fieldName: fieldKey,\n      arguments: null,\n    };\n  }\n};\n\nexport const serializeKeys = (entityKey: string, fieldKey: string) =>\n  `${entityKey.replace(/\\./g, '%2e')}.${fieldKey}`;\n\nexport const deserializeKeyInfo = (key: string): KeyInfo => {\n  const dotIndex = key.indexOf('.');\n  const entityKey = key.slice(0, dotIndex).replace(/%2e/g, '.');\n  const fieldKey = key.slice(dotIndex + 1);\n  return { entityKey, fieldKey };\n};\n","import { stringifyVariables } from '@urql/core';\n\nimport type {\n  Link,\n  EntityField,\n  FieldInfo,\n  StorageAdapter,\n  SerializedEntries,\n  Dependencies,\n  OperationType,\n  DataField,\n  Data,\n} from '../types';\n\nimport {\n  serializeKeys,\n  deserializeKeyInfo,\n  fieldInfoOfKey,\n  joinKeys,\n} from './keys';\n\nimport { invariant, currentDebugStack } from '../helpers/help';\n\ntype Dict<T> = Record<string, T>;\ntype KeyMap<T> = Map<string, T>;\ntype OperationMap<T> = Map<number, T>;\n\ninterface NodeMap<T> {\n  optimistic: OperationMap<KeyMap<Dict<T | undefined>>>;\n  base: KeyMap<Dict<T>>;\n}\n\nexport interface InMemoryData {\n  /** Flag for whether the data is waiting for hydration */\n  hydrating: boolean;\n  /** Flag for whether deferred tasks have been scheduled yet */\n  defer: boolean;\n  /** A list of entities that have been flagged for gargabe collection since no references to them are left */\n  gc: Set<string>;\n  /** A list of entity+field keys that will be persisted */\n  persist: Set<string>;\n  /** The API's \"Query\" typename which is needed to filter dependencies */\n  queryRootKey: string;\n  /** Number of references to each entity (except \"Query\") */\n  refCount: KeyMap<number>;\n  /** A map of entity fields (key-value entries per entity) */\n  records: NodeMap<EntityField>;\n  /** A map of entity links which are connections from one entity to another (key-value entries per entity) */\n  links: NodeMap<Link>;\n  /** A map of typename to a list of entity-keys belonging to said type */\n  types: Map<string, Set<string>>;\n  /** A set of Query operation keys that are in-flight and deferred/streamed */\n  deferredKeys: Set<number>;\n  /** A set of Query operation keys that are in-flight and awaiting a result */\n  commutativeKeys: Set<number>;\n  /** A set of Query operation keys that have been written to */\n  dirtyKeys: Set<number>;\n  /** The order of optimistic layers */\n  optimisticOrder: number[];\n  /** This may be a persistence adapter that will receive changes in a batch */\n  storage: StorageAdapter | null;\n  /** A map of all the types we have encountered that did not map directly to a concrete type */\n  abstractToConcreteMap: Map<string, Set<string>>;\n}\n\nlet currentOwnership: null | WeakSet<any> = null;\nlet currentDataMapping: null | WeakMap<any, any> = null;\nlet currentData: null | InMemoryData = null;\nlet currentOptimisticKey: null | number = null;\nexport let currentOperation: null | OperationType = null;\nexport let currentDependencies: null | Dependencies = null;\nexport let currentForeignData = false;\nexport let currentOptimistic = false;\n\nexport function makeData(data: DataField | void, isArray?: false): Data;\nexport function makeData(data: DataField | void, isArray: true): DataField[];\n\n/** Creates a new data object unless it's been created in this data run */\nexport function makeData(data?: DataField | void, isArray?: boolean) {\n  let newData: Data | Data[] | undefined;\n  if (data) {\n    if (currentOwnership!.has(data)) return data;\n    newData = currentDataMapping!.get(data) as any;\n  }\n\n  if (newData == null) {\n    newData = (isArray ? [] : {}) as any;\n  }\n\n  if (data) {\n    currentDataMapping!.set(data, newData);\n  }\n\n  currentOwnership!.add(newData);\n  return newData;\n}\n\nexport const ownsData = (data?: Data): boolean =>\n  !!data && currentOwnership!.has(data);\n\n/** Before reading or writing the global state needs to be initialised */\nexport const initDataState = (\n  operationType: OperationType,\n  data: InMemoryData,\n  layerKey?: number | null,\n  isOptimistic?: boolean,\n  isForeignData?: boolean\n) => {\n  currentOwnership = new WeakSet();\n  currentDataMapping = new WeakMap();\n  currentOperation = operationType;\n  currentData = data;\n  currentDependencies = new Set();\n  currentOptimistic = !!isOptimistic;\n  currentForeignData = !!isForeignData;\n  if (process.env.NODE_ENV !== 'production') {\n    currentDebugStack.length = 0;\n  }\n\n  if (!layerKey) {\n    currentOptimisticKey = null;\n  } else if (currentOperation === 'read') {\n    // We don't create new layers for read operations and instead simply\n    // apply the currently available layer, if any\n    currentOptimisticKey = layerKey;\n  } else if (\n    isOptimistic ||\n    data.hydrating ||\n    data.optimisticOrder.length > 1\n  ) {\n    // If this operation isn't optimistic and we see it for the first time,\n    // then it must've been optimistic in the past, so we can proactively\n    // clear the optimistic data before writing\n    if (!isOptimistic && !data.commutativeKeys.has(layerKey)) {\n      reserveLayer(data, layerKey);\n    } else if (isOptimistic) {\n      if (\n        data.optimisticOrder.indexOf(layerKey) !== -1 &&\n        !data.commutativeKeys.has(layerKey)\n      ) {\n        data.optimisticOrder.splice(data.optimisticOrder.indexOf(layerKey), 1);\n      }\n      // NOTE: This optimally shouldn't happen as it implies that an optimistic\n      // write is being performed after a concrete write.\n      data.commutativeKeys.delete(layerKey);\n    }\n\n    // An optimistic update of a mutation may force an optimistic layer,\n    // or this Query update may be applied optimistically since it's part\n    // of a commutative chain\n    currentOptimisticKey = layerKey;\n    createLayer(data, layerKey);\n  } else {\n    // Otherwise we don't create an optimistic layer and clear the\n    // operation's one if it already exists\n    // We also do this when only one layer exists to avoid having to squash\n    // any layers at the end of writing this layer\n    currentOptimisticKey = null;\n    deleteLayer(data, layerKey);\n  }\n};\n\n/** Reset the data state after read/write is complete */\nexport const clearDataState = () => {\n  // NOTE: This is only called to check for the invariant to pass\n  if (process.env.NODE_ENV !== 'production') {\n    getCurrentDependencies();\n  }\n\n  const data = currentData!;\n  const layerKey = currentOptimisticKey;\n  currentOptimistic = false;\n  currentOptimisticKey = null;\n\n  // Determine whether the current operation has been a commutative layer\n  if (\n    !data.hydrating &&\n    layerKey &&\n    data.optimisticOrder.indexOf(layerKey) > -1\n  ) {\n    // Squash all layers in reverse order (low priority upwards) that have\n    // been written already\n    let i = data.optimisticOrder.length;\n    while (\n      --i >= 0 &&\n      data.dirtyKeys.has(data.optimisticOrder[i]) &&\n      data.commutativeKeys.has(data.optimisticOrder[i])\n    )\n      squashLayer(data.optimisticOrder[i]);\n  }\n\n  currentOwnership = null;\n  currentDataMapping = null;\n  currentOperation = null;\n  currentData = null;\n  currentDependencies = null;\n  if (process.env.NODE_ENV !== 'production') {\n    currentDebugStack.length = 0;\n  }\n\n  if (process.env.NODE_ENV !== 'test') {\n    // Schedule deferred tasks if we haven't already, and if either a persist or GC run\n    // are likely to be needed\n    if (!data.defer && (data.storage || !data.optimisticOrder.length)) {\n      data.defer = true;\n      setTimeout(() => {\n        initDataState('read', data, null);\n        gc();\n        persistData();\n        clearDataState();\n        data.defer = false;\n      });\n    }\n  }\n};\n\n/** Initialises then resets the data state, which may squash this layer if necessary */\nexport const noopDataState = (\n  data: InMemoryData,\n  layerKey: number | null,\n  isOptimistic?: boolean\n) => {\n  if (layerKey && !isOptimistic) data.deferredKeys.delete(layerKey);\n  initDataState('write', data, layerKey, isOptimistic);\n  clearDataState();\n};\n\n/** As we're writing, we keep around all the records and links we've read or have written to */\nexport const getCurrentDependencies = (): Dependencies => {\n  invariant(\n    currentDependencies !== null,\n    'Invalid Cache call: The cache may only be accessed or mutated during' +\n      'operations like write or query, or as part of its resolvers, updaters, ' +\n      'or optimistic configs.',\n    2\n  );\n\n  return currentDependencies;\n};\n\nconst DEFAULT_EMPTY_SET = new Set<string>();\nexport const make = (queryRootKey: string): InMemoryData => ({\n  hydrating: false,\n  defer: false,\n  gc: new Set(),\n  types: new Map(),\n  persist: new Set(),\n  queryRootKey,\n  refCount: new Map(),\n  links: {\n    optimistic: new Map(),\n    base: new Map(),\n  },\n  abstractToConcreteMap: new Map(),\n  records: {\n    optimistic: new Map(),\n    base: new Map(),\n  },\n  deferredKeys: new Set(),\n  commutativeKeys: new Set(),\n  dirtyKeys: new Set(),\n  optimisticOrder: [],\n  storage: null,\n});\n\n/** Adds a node value to a NodeMap (taking optimistic values into account */\nconst setNode = <T>(\n  map: NodeMap<T>,\n  entityKey: string,\n  fieldKey: string,\n  value: T\n) => {\n  if (process.env.NODE_ENV !== 'production') {\n    invariant(\n      currentOperation !== 'read',\n      'Invalid Cache write: You may not write to the cache during cache reads. ' +\n        ' Accesses to `cache.writeFragment`, `cache.updateQuery`, and `cache.link` may ' +\n        ' not be made inside `resolvers` for instance.',\n      27\n    );\n  }\n\n  // Optimistic values are written to a map in the optimistic dict\n  // All other values are written to the base map\n  const keymap: KeyMap<Dict<T | undefined>> = currentOptimisticKey\n    ? map.optimistic.get(currentOptimisticKey)!\n    : map.base;\n\n  // On the map itself we get or create the entity as a dict\n  let entity = keymap.get(entityKey) as Dict<T | undefined>;\n  if (entity === undefined) {\n    keymap.set(entityKey, (entity = Object.create(null)));\n  }\n\n  // If we're setting undefined we delete the node's entry\n  // On optimistic layers we actually set undefined so it can\n  // override the base value\n  if (value === undefined && !currentOptimisticKey) {\n    delete entity[fieldKey];\n  } else {\n    entity[fieldKey] = value;\n  }\n};\n\n/** Gets a node value from a NodeMap (taking optimistic values into account */\nconst getNode = <T>(\n  map: NodeMap<T>,\n  entityKey: string,\n  fieldKey: string\n): T | undefined => {\n  let node: Dict<T | undefined> | undefined;\n  // A read may be initialised to skip layers until its own, which is useful for\n  // reading back written data. It won't skip over optimistic layers however\n  let skip =\n    !currentOptimistic &&\n    currentOperation === 'read' &&\n    currentOptimisticKey &&\n    currentData!.commutativeKeys.has(currentOptimisticKey);\n  // This first iterates over optimistic layers (in order)\n  for (let i = 0, l = currentData!.optimisticOrder.length; i < l; i++) {\n    const layerKey = currentData!.optimisticOrder[i];\n    const optimistic = map.optimistic.get(layerKey);\n    // If we're reading starting from a specific layer, we skip until a match\n    skip = skip && layerKey !== currentOptimisticKey;\n    // If the node and node value exists it is returned, including undefined\n    if (\n      optimistic &&\n      (!skip || !currentData!.commutativeKeys.has(layerKey)) &&\n      (!currentOptimistic ||\n        currentOperation === 'write' ||\n        currentData!.commutativeKeys.has(layerKey)) &&\n      (node = optimistic.get(entityKey)) !== undefined &&\n      fieldKey in node\n    ) {\n      return node[fieldKey];\n    }\n  }\n\n  // Otherwise we read the non-optimistic base value\n  node = map.base.get(entityKey);\n  return node !== undefined ? node[fieldKey] : undefined;\n};\n\nexport function getRefCount(entityKey: string): number {\n  return currentData!.refCount.get(entityKey) || 0;\n}\n\n/** Adjusts the reference count of an entity on a refCount dict by \"by\" and updates the gc */\nconst updateRCForEntity = (entityKey: string, by: number): void => {\n  // Retrieve the reference count and adjust it by \"by\"\n  const count = getRefCount(entityKey);\n  const newCount = count + by > 0 ? count + by : 0;\n  currentData!.refCount.set(entityKey, newCount);\n  // Add it to the garbage collection batch if it needs to be deleted or remove it\n  // from the batch if it needs to be kept\n  if (!newCount) currentData!.gc.add(entityKey);\n  else if (!count && newCount) currentData!.gc.delete(entityKey);\n};\n\n/** Adjusts the reference counts of all entities of a link on a refCount dict by \"by\" and updates the gc */\nconst updateRCForLink = (link: Link | undefined, by: number): void => {\n  if (Array.isArray(link)) {\n    for (let i = 0, l = link.length; i < l; i++) updateRCForLink(link[i], by);\n  } else if (typeof link === 'string') {\n    updateRCForEntity(link, by);\n  }\n};\n\n/** Writes all parsed FieldInfo objects of a given node dict to a given array if it hasn't been seen */\nconst extractNodeFields = <T>(\n  fieldInfos: FieldInfo[],\n  seenFieldKeys: Set<string>,\n  node: Dict<T> | undefined\n): void => {\n  if (node !== undefined) {\n    for (const fieldKey in node) {\n      if (!seenFieldKeys.has(fieldKey)) {\n        // If the node hasn't been seen the serialized fieldKey is turnt back into\n        // a rich FieldInfo object that also contains the field's name and arguments\n        fieldInfos.push(fieldInfoOfKey(fieldKey));\n        seenFieldKeys.add(fieldKey);\n      }\n    }\n  }\n};\n\n/** Writes all parsed FieldInfo objects of all nodes in a NodeMap to a given array */\nconst extractNodeMapFields = <T>(\n  fieldInfos: FieldInfo[],\n  seenFieldKeys: Set<string>,\n  entityKey: string,\n  map: NodeMap<T>\n) => {\n  // Extracts FieldInfo for the entity in the base map\n  extractNodeFields(fieldInfos, seenFieldKeys, map.base.get(entityKey));\n\n  // Then extracts FieldInfo for the entity from the optimistic maps\n  for (let i = 0, l = currentData!.optimisticOrder.length; i < l; i++) {\n    const optimistic = map.optimistic.get(currentData!.optimisticOrder[i]);\n    if (optimistic !== undefined) {\n      extractNodeFields(fieldInfos, seenFieldKeys, optimistic.get(entityKey));\n    }\n  }\n};\n\n/** Garbage collects all entities that have been marked as having no references */\nexport const gc = () => {\n  // If we're currently awaiting deferred results, abort GC run\n  if (currentData!.optimisticOrder.length) return;\n\n  // Iterate over all entities that have been marked for deletion\n  // Entities have been marked for deletion in `updateRCForEntity` if\n  // their reference count dropped to 0\n  for (const entityKey of currentData!.gc.keys()) {\n    // Remove the current key from the GC batch\n    currentData!.gc.delete(entityKey);\n\n    // Check first whether the entity has any references,\n    // if so, we skip it from the GC run\n    const rc = getRefCount(entityKey);\n    if (rc > 0) continue;\n\n    const record = currentData!.records.base.get(entityKey);\n    // Delete the reference count, and delete the entity from the GC batch\n    currentData!.refCount.delete(entityKey);\n    currentData!.records.base.delete(entityKey);\n\n    const typename = (record && record.__typename) as string | undefined;\n    if (typename) {\n      const type = currentData!.types.get(typename);\n      if (type) type.delete(entityKey);\n    }\n\n    const linkNode = currentData!.links.base.get(entityKey);\n    if (linkNode) {\n      currentData!.links.base.delete(entityKey);\n      for (const fieldKey in linkNode) updateRCForLink(linkNode[fieldKey], -1);\n    }\n  }\n};\n\nconst updateDependencies = (entityKey: string, fieldKey?: string) => {\n  if (entityKey !== currentData!.queryRootKey) {\n    currentDependencies!.add(entityKey);\n  } else if (fieldKey !== undefined && fieldKey !== '__typename') {\n    currentDependencies!.add(joinKeys(entityKey, fieldKey));\n  }\n};\n\nconst updatePersist = (entityKey: string, fieldKey: string) => {\n  if (!currentOptimistic && currentData!.storage) {\n    currentData!.persist.add(serializeKeys(entityKey, fieldKey));\n  }\n};\n\n/** Reads an entity's field (a \"record\") from data */\nexport const readRecord = (\n  entityKey: string,\n  fieldKey: string\n): EntityField => {\n  if (currentOperation === 'read') {\n    updateDependencies(entityKey, fieldKey);\n  }\n  return getNode(currentData!.records, entityKey, fieldKey);\n};\n\n/** Reads an entity's link from data */\nexport const readLink = (\n  entityKey: string,\n  fieldKey: string\n): Link | undefined => {\n  if (currentOperation === 'read') {\n    updateDependencies(entityKey, fieldKey);\n  }\n  return getNode(currentData!.links, entityKey, fieldKey);\n};\n\nexport const getEntitiesForType = (typename: string): Set<string> =>\n  currentData!.types.get(typename) || DEFAULT_EMPTY_SET;\n\nexport const writeType = (typename: string, entityKey: string) => {\n  const existingTypes = currentData!.types.get(typename);\n  if (!existingTypes) {\n    const typeSet = new Set<string>();\n    typeSet.add(entityKey);\n    currentData!.types.set(typename, typeSet);\n  } else {\n    existingTypes.add(entityKey);\n  }\n};\n\nexport const getConcreteTypes = (typename: string): Set<string> =>\n  currentData!.abstractToConcreteMap.get(typename) || DEFAULT_EMPTY_SET;\n\nexport const isSeenConcreteType = (typename: string): boolean =>\n  currentData!.types.has(typename);\n\nexport const writeConcreteType = (\n  abstractType: string,\n  concreteType: string\n) => {\n  const existingTypes = currentData!.abstractToConcreteMap.get(abstractType);\n  if (!existingTypes) {\n    const typeSet = new Set<string>();\n    typeSet.add(concreteType);\n    currentData!.abstractToConcreteMap.set(abstractType, typeSet);\n  } else {\n    existingTypes.add(concreteType);\n  }\n};\n\n/** Writes an entity's field (a \"record\") to data */\nexport const writeRecord = (\n  entityKey: string,\n  fieldKey: string,\n  value?: EntityField\n) => {\n  const existing = getNode(currentData!.records, entityKey, fieldKey);\n  if (!isEqualLinkOrScalar(existing, value)) {\n    updateDependencies(entityKey, fieldKey);\n    updatePersist(entityKey, fieldKey);\n  }\n\n  setNode(currentData!.records, entityKey, fieldKey, value);\n};\n\nexport const hasField = (entityKey: string, fieldKey: string): boolean =>\n  readRecord(entityKey, fieldKey) !== undefined ||\n  readLink(entityKey, fieldKey) !== undefined;\n\n/** Writes an entity's link to data */\nexport const writeLink = (\n  entityKey: string,\n  fieldKey: string,\n  link?: Link | undefined\n) => {\n  // Retrieve the link NodeMap from either an optimistic or the base layer\n  const links = currentOptimisticKey\n    ? currentData!.links.optimistic.get(currentOptimisticKey)\n    : currentData!.links.base;\n  // Update the reference count for the link\n  if (!currentOptimisticKey) {\n    const entityLinks = links && links.get(entityKey);\n    updateRCForLink(entityLinks && entityLinks[fieldKey], -1);\n    updateRCForLink(link, 1);\n  }\n  const existing = getNode(currentData!.links, entityKey, fieldKey);\n  if (!isEqualLinkOrScalar(existing, link)) {\n    updateDependencies(entityKey, fieldKey);\n    updatePersist(entityKey, fieldKey);\n  }\n\n  // Update the link\n  setNode(currentData!.links, entityKey, fieldKey, link);\n};\n\n/** Reserves an optimistic layer and preorders it */\nexport const reserveLayer = (\n  data: InMemoryData,\n  layerKey: number,\n  hasNext?: boolean\n) => {\n  // Find the current index for the layer, and remove it from\n  // the order if it exists already\n  let index = data.optimisticOrder.indexOf(layerKey);\n  if (index > -1) data.optimisticOrder.splice(index, 1);\n\n  if (hasNext) {\n    data.deferredKeys.add(layerKey);\n    // If the layer has future results then we'll move it past any layer that's\n    // still empty, so currently pending operations will take precedence over it\n    for (\n      index = index > -1 ? index : 0;\n      index < data.optimisticOrder.length &&\n      !data.deferredKeys.has(data.optimisticOrder[index]) &&\n      (!data.dirtyKeys.has(data.optimisticOrder[index]) ||\n        !data.commutativeKeys.has(data.optimisticOrder[index]));\n      index++\n    );\n  } else {\n    data.deferredKeys.delete(layerKey);\n    // Protect optimistic layers from being turned into non-optimistic layers\n    // while preserving optimistic data\n    if (index > -1 && !data.commutativeKeys.has(layerKey))\n      clearLayer(data, layerKey);\n    index = 0;\n  }\n\n  // Register the layer with the deferred or \"top\" index and\n  // mark it as commutative\n  data.optimisticOrder.splice(index, 0, layerKey);\n  data.commutativeKeys.add(layerKey);\n};\n\n/** Checks whether a given layer exists */\nexport const hasLayer = (data: InMemoryData, layerKey: number) =>\n  data.commutativeKeys.has(layerKey) ||\n  data.optimisticOrder.indexOf(layerKey) > -1;\n\n/** Creates an optimistic layer of links and records */\nconst createLayer = (data: InMemoryData, layerKey: number) => {\n  if (data.optimisticOrder.indexOf(layerKey) === -1) {\n    data.optimisticOrder.unshift(layerKey);\n  }\n\n  if (!data.dirtyKeys.has(layerKey)) {\n    data.dirtyKeys.add(layerKey);\n    data.links.optimistic.set(layerKey, new Map());\n    data.records.optimistic.set(layerKey, new Map());\n  }\n};\n\n/** Clears all links and records of an optimistic layer */\nconst clearLayer = (data: InMemoryData, layerKey: number) => {\n  if (data.dirtyKeys.has(layerKey)) {\n    data.dirtyKeys.delete(layerKey);\n    data.records.optimistic.delete(layerKey);\n    data.links.optimistic.delete(layerKey);\n    data.deferredKeys.delete(layerKey);\n  }\n};\n\n/** Deletes links and records of an optimistic layer, and the layer itself */\nconst deleteLayer = (data: InMemoryData, layerKey: number) => {\n  const index = data.optimisticOrder.indexOf(layerKey);\n  if (index > -1) {\n    data.optimisticOrder.splice(index, 1);\n    data.commutativeKeys.delete(layerKey);\n  }\n\n  clearLayer(data, layerKey);\n};\n\n/** Merges an optimistic layer of links and records into the base data */\nconst squashLayer = (layerKey: number) => {\n  // Hide current dependencies from squashing operations\n  const previousDependencies = currentDependencies;\n  currentDependencies = new Set();\n  currentOperation = 'write';\n\n  const links = currentData!.links.optimistic.get(layerKey);\n  if (links) {\n    for (const entry of links.entries()) {\n      const entityKey = entry[0];\n      const keyMap = entry[1];\n      for (const fieldKey in keyMap) {\n        writeLink(entityKey, fieldKey, keyMap[fieldKey]);\n      }\n    }\n  }\n\n  const records = currentData!.records.optimistic.get(layerKey);\n  if (records) {\n    for (const entry of records.entries()) {\n      const entityKey = entry[0];\n      const keyMap = entry[1];\n      for (const fieldKey in keyMap) {\n        writeRecord(entityKey, fieldKey, keyMap[fieldKey]);\n      }\n    }\n  }\n\n  currentDependencies = previousDependencies;\n  deleteLayer(currentData!, layerKey);\n};\n\n/** Return an array of FieldInfo (info on all the fields and their arguments) for a given entity */\nexport const inspectFields = (entityKey: string): FieldInfo[] => {\n  const { links, records } = currentData!;\n  const fieldInfos: FieldInfo[] = [];\n  const seenFieldKeys: Set<string> = new Set();\n  // Update dependencies\n  updateDependencies(entityKey);\n  // Extract FieldInfos to the fieldInfos array for links and records\n  // This also deduplicates by keeping track of fieldKeys in the seenFieldKeys Set\n  extractNodeMapFields(fieldInfos, seenFieldKeys, entityKey, links);\n  extractNodeMapFields(fieldInfos, seenFieldKeys, entityKey, records);\n  return fieldInfos;\n};\n\nexport const persistData = () => {\n  if (currentData!.storage) {\n    currentOptimistic = true;\n    currentOperation = 'read';\n    const entries: SerializedEntries = {};\n    for (const key of currentData!.persist.keys()) {\n      const { entityKey, fieldKey } = deserializeKeyInfo(key);\n      let x: void | Link | EntityField;\n      if ((x = readLink(entityKey, fieldKey)) !== undefined) {\n        entries[key] = `:${stringifyVariables(x)}`;\n      } else if ((x = readRecord(entityKey, fieldKey)) !== undefined) {\n        entries[key] = stringifyVariables(x);\n      } else {\n        entries[key] = undefined;\n      }\n    }\n\n    currentOptimistic = false;\n    currentData!.storage.writeData(entries);\n    currentData!.persist.clear();\n  }\n};\n\nexport const hydrateData = (\n  data: InMemoryData,\n  storage: StorageAdapter,\n  entries: SerializedEntries\n) => {\n  initDataState('write', data, null);\n\n  for (const key in entries) {\n    const value = entries[key];\n    if (value !== undefined) {\n      const { entityKey, fieldKey } = deserializeKeyInfo(key);\n      if (value[0] === ':') {\n        if (readLink(entityKey, fieldKey) === undefined)\n          writeLink(entityKey, fieldKey, JSON.parse(value.slice(1)));\n      } else {\n        if (readRecord(entityKey, fieldKey) === undefined)\n          writeRecord(entityKey, fieldKey, JSON.parse(value));\n      }\n    }\n  }\n\n  data.storage = storage;\n  data.hydrating = false;\n  clearDataState();\n};\n\nfunction isEqualLinkOrScalar(\n  a: Link | EntityField | undefined,\n  b: Link | EntityField | undefined\n) {\n  if (typeof a !== typeof b) return false;\n  if (a !== b) return false;\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    return !a.some((el, index) => el !== b[index]);\n  }\n\n  return true;\n}\n","import type { CombinedError, ErrorLike, FormattedNode } from '@urql/core';\n\nimport type {\n  FieldNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from '@0no-co/graphql.web';\nimport { Kind } from '@0no-co/graphql.web';\n\nimport type { SelectionSet } from '../ast';\nimport {\n  isDeferred,\n  getTypeCondition,\n  getSelectionSet,\n  getName,\n  isOptional,\n} from '../ast';\n\nimport { warn, pushDebugNode, popDebugNode } from '../helpers/help';\nimport {\n  hasField,\n  currentOperation,\n  currentOptimistic,\n  writeConcreteType,\n  getConcreteTypes,\n  isSeenConcreteType,\n} from '../store/data';\nimport { keyOfField } from '../store/keys';\nimport type { Store } from '../store/store';\n\nimport { getFieldArguments, shouldInclude, isInterfaceOfType } from '../ast';\n\nimport type {\n  Fragments,\n  Variables,\n  DataField,\n  NullArray,\n  Link,\n  Entity,\n  Data,\n  Logger,\n} from '../types';\n\nexport interface Context {\n  store: Store;\n  variables: Variables;\n  fragments: Fragments;\n  parentTypeName: string;\n  parentKey: string;\n  parentFieldKey: string;\n  parent: Data;\n  fieldName: string;\n  error: ErrorLike | undefined;\n  partial: boolean;\n  hasNext: boolean;\n  optimistic: boolean;\n  __internal: {\n    path: Array<string | number>;\n    errorMap: { [path: string]: ErrorLike } | undefined;\n  };\n}\n\nexport let contextRef: Context | null = null;\nexport let deferRef = false;\nexport let optionalRef: boolean | undefined = undefined;\n\n// Checks whether the current data field is a cache miss because of a GraphQLError\nexport const getFieldError = (ctx: Context): ErrorLike | undefined =>\n  ctx.__internal.path.length > 0 && ctx.__internal.errorMap\n    ? ctx.__internal.errorMap[ctx.__internal.path.join('.')]\n    : undefined;\n\nexport const makeContext = (\n  store: Store,\n  variables: Variables,\n  fragments: Fragments,\n  typename: string,\n  entityKey: string,\n  error: CombinedError | undefined\n): Context => {\n  const ctx: Context = {\n    store,\n    variables,\n    fragments,\n    parent: { __typename: typename },\n    parentTypeName: typename,\n    parentKey: entityKey,\n    parentFieldKey: '',\n    fieldName: '',\n    error: undefined,\n    partial: false,\n    hasNext: false,\n    optimistic: currentOptimistic,\n    __internal: {\n      path: [],\n      errorMap: undefined,\n    },\n  };\n\n  if (error && error.graphQLErrors) {\n    for (let i = 0; i < error.graphQLErrors.length; i++) {\n      const graphQLError = error.graphQLErrors[i];\n      if (graphQLError.path && graphQLError.path.length) {\n        if (!ctx.__internal.errorMap)\n          ctx.__internal.errorMap = Object.create(null);\n        ctx.__internal.errorMap![graphQLError.path.join('.')] = graphQLError;\n      }\n    }\n  }\n\n  return ctx;\n};\n\nexport const updateContext = (\n  ctx: Context,\n  data: Data,\n  typename: string,\n  entityKey: string,\n  fieldKey: string,\n  fieldName: string\n) => {\n  contextRef = ctx;\n  ctx.parent = data;\n  ctx.parentTypeName = typename;\n  ctx.parentKey = entityKey;\n  ctx.parentFieldKey = fieldKey;\n  ctx.fieldName = fieldName;\n  ctx.error = getFieldError(ctx);\n};\n\nconst isFragmentHeuristicallyMatching = (\n  node: FormattedNode<InlineFragmentNode | FragmentDefinitionNode>,\n  typename: void | string,\n  entityKey: string,\n  vars: Variables,\n  logger?: Logger\n) => {\n  if (!typename) return false;\n  const typeCondition = getTypeCondition(node);\n  if (!typeCondition || typename === typeCondition) return true;\n\n  warn(\n    'Heuristic Fragment Matching: A fragment is trying to match against the `' +\n      typename +\n      '` type, ' +\n      'but the type condition is `' +\n      typeCondition +\n      '`. Since GraphQL allows for interfaces `' +\n      typeCondition +\n      '` may be an ' +\n      'interface.\\nA schema needs to be defined for this match to be deterministic, ' +\n      'otherwise the fragment will be matched heuristically!',\n    16,\n    logger\n  );\n\n  return !getSelectionSet(node).some(node => {\n    if (node.kind !== Kind.FIELD) return false;\n    const fieldKey = keyOfField(getName(node), getFieldArguments(node, vars));\n    return !hasField(entityKey, fieldKey);\n  });\n};\n\ninterface SelectionIterator {\n  (): FormattedNode<FieldNode> | undefined;\n}\n\n// NOTE: Outside of this file, we expect `_defer` to always be reset to `false`\nexport function makeSelectionIterator(\n  typename: undefined | string,\n  entityKey: string,\n  _defer: false,\n  _optional: undefined,\n  selectionSet: FormattedNode<SelectionSet>,\n  ctx: Context\n): SelectionIterator;\n// NOTE: Inside this file we expect the state to be recursively passed on\nexport function makeSelectionIterator(\n  typename: undefined | string,\n  entityKey: string,\n  _defer: boolean,\n  _optional: undefined | boolean,\n  selectionSet: FormattedNode<SelectionSet>,\n  ctx: Context\n): SelectionIterator;\n\nexport function makeSelectionIterator(\n  typename: undefined | string,\n  entityKey: string,\n  _defer: boolean,\n  _optional: boolean | undefined,\n  selectionSet: FormattedNode<SelectionSet>,\n  ctx: Context\n): SelectionIterator {\n  let child: SelectionIterator | void;\n  let index = 0;\n\n  return function next() {\n    let node: FormattedNode<FieldNode> | undefined;\n    while (child || index < selectionSet.length) {\n      node = undefined;\n      deferRef = _defer;\n      optionalRef = _optional;\n      if (child) {\n        if ((node = child())) {\n          return node;\n        } else {\n          child = undefined;\n          if (process.env.NODE_ENV !== 'production') popDebugNode();\n        }\n      } else {\n        const select = selectionSet[index++];\n        if (!shouldInclude(select, ctx.variables)) {\n          /*noop*/\n        } else if (select.kind !== Kind.FIELD) {\n          // A fragment is either referred to by FragmentSpread or inline\n          const fragment =\n            select.kind !== Kind.INLINE_FRAGMENT\n              ? ctx.fragments[getName(select)]\n              : select;\n          if (fragment) {\n            const isMatching =\n              !fragment.typeCondition ||\n              (ctx.store.schema\n                ? isInterfaceOfType(ctx.store.schema, fragment, typename)\n                : (currentOperation === 'read' &&\n                    isFragmentMatching(\n                      fragment.typeCondition.name.value,\n                      typename\n                    )) ||\n                  isFragmentHeuristicallyMatching(\n                    fragment,\n                    typename,\n                    entityKey,\n                    ctx.variables,\n                    ctx.store.logger\n                  ));\n\n            if (\n              isMatching ||\n              (currentOperation === 'write' && !ctx.store.schema)\n            ) {\n              if (process.env.NODE_ENV !== 'production')\n                pushDebugNode(typename, fragment);\n              const isFragmentOptional = isOptional(select);\n              if (\n                isMatching &&\n                fragment.typeCondition &&\n                typename !== fragment.typeCondition.name.value\n              ) {\n                writeConcreteType(fragment.typeCondition.name.value, typename!);\n              }\n\n              child = makeSelectionIterator(\n                typename,\n                entityKey,\n                _defer || isDeferred(select, ctx.variables),\n                isFragmentOptional !== undefined\n                  ? isFragmentOptional\n                  : _optional,\n                getSelectionSet(fragment),\n                ctx\n              );\n            }\n          }\n        } else if (currentOperation === 'write' || !select._generated) {\n          return select;\n        }\n      }\n    }\n  };\n}\n\nconst isFragmentMatching = (typeCondition: string, typename: string | void) => {\n  if (!typename) return false;\n  if (typeCondition === typename) return true;\n\n  const isProbableAbstractType = !isSeenConcreteType(typeCondition);\n  if (!isProbableAbstractType) return false;\n\n  const types = getConcreteTypes(typeCondition);\n  return types.size && types.has(typename);\n};\n\nexport const ensureData = (x: DataField): Data | NullArray<Data> | null =>\n  x == null ? null : (x as Data | NullArray<Data>);\n\nexport const ensureLink = (store: Store, ref: Link<Entity>): Link => {\n  if (!ref) {\n    return ref || null;\n  } else if (Array.isArray(ref)) {\n    const link = new Array(ref.length);\n    for (let i = 0, l = link.length; i < l; i++)\n      link[i] = ensureLink(store, ref[i]);\n    return link;\n  }\n\n  const link = store.keyOfEntity(ref);\n  if (!link && ref && typeof ref === 'object') {\n    warn(\n      \"Can't generate a key for link(...) item.\" +\n        '\\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        ref.__typename +\n        '`.',\n      12,\n      store.logger\n    );\n  }\n\n  return link;\n};\n","import type { FormattedNode, CombinedError } from '@urql/core';\nimport { formatDocument } from '@urql/core';\n\nimport type {\n  FieldNode,\n  DocumentNode,\n  FragmentDefinitionNode,\n} from '@0no-co/graphql.web';\n\nimport type { SelectionSet } from '../ast';\nimport {\n  getSelectionSet,\n  getName,\n  getFragmentTypeName,\n  getFieldAlias,\n  getFragments,\n  getMainOperation,\n  normalizeVariables,\n  getFieldArguments,\n  getDirectives,\n} from '../ast';\n\nimport type {\n  Variables,\n  Data,\n  DataField,\n  Link,\n  OperationRequest,\n  Dependencies,\n  Resolver,\n} from '../types';\n\nimport { joinKeys, keyOfField } from '../store/keys';\nimport type { Store } from '../store/store';\nimport * as InMemoryData from '../store/data';\nimport { warn, pushDebugNode, popDebugNode } from '../helpers/help';\n\nimport type { Context } from './shared';\nimport {\n  makeSelectionIterator,\n  ensureData,\n  makeContext,\n  updateContext,\n  getFieldError,\n  deferRef,\n  optionalRef,\n} from './shared';\n\nimport {\n  isFieldAvailableOnType,\n  isFieldNullable,\n  isListNullable,\n} from '../ast';\n\nexport interface QueryResult {\n  dependencies: Dependencies;\n  partial: boolean;\n  hasNext: boolean;\n  data: null | Data;\n}\n\n/** Reads a GraphQL query from the cache.\n * @internal\n */\nexport const __initAnd_query = (\n  store: Store,\n  request: OperationRequest,\n  data?: Data | null | undefined,\n  error?: CombinedError | undefined,\n  key?: number\n): QueryResult => {\n  InMemoryData.initDataState('read', store.data, key);\n  const result = _query(store, request, data, error);\n  InMemoryData.clearDataState();\n  return result;\n};\n\n/** Reads a GraphQL query from the cache.\n * @internal\n */\nexport const _query = (\n  store: Store,\n  request: OperationRequest,\n  input?: Data | null | undefined,\n  error?: CombinedError | undefined\n): QueryResult => {\n  const query = formatDocument(request.query);\n  const operation = getMainOperation(query);\n  const rootKey = store.rootFields[operation.operation];\n  const rootSelect = getSelectionSet(operation);\n\n  const ctx = makeContext(\n    store,\n    normalizeVariables(operation, request.variables),\n    getFragments(query),\n    rootKey,\n    rootKey,\n    error\n  );\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(rootKey, operation);\n  }\n\n  // NOTE: This may reuse \"previous result data\" as indicated by the\n  // `originalData` argument in readRoot(). This behaviour isn't used\n  // for readSelection() however, which always produces results from\n  // scratch\n  const data =\n    rootKey !== ctx.store.rootFields['query']\n      ? readRoot(ctx, rootKey, rootSelect, input || InMemoryData.makeData())\n      : readSelection(\n          ctx,\n          rootKey,\n          rootSelect,\n          input || InMemoryData.makeData()\n        );\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n    InMemoryData.getCurrentDependencies();\n  }\n\n  return {\n    dependencies: InMemoryData.currentDependencies!,\n    partial: ctx.partial || !data,\n    hasNext: ctx.hasNext,\n    data: data || null,\n  };\n};\n\nconst readRoot = (\n  ctx: Context,\n  entityKey: string,\n  select: FormattedNode<SelectionSet>,\n  input: Data\n): Data => {\n  const typename = ctx.store.rootNames[entityKey]\n    ? entityKey\n    : input.__typename;\n  if (typeof typename !== 'string') {\n    return input;\n  }\n\n  const iterate = makeSelectionIterator(\n    entityKey,\n    entityKey,\n    false,\n    undefined,\n    select,\n    ctx\n  );\n\n  let node: FormattedNode<FieldNode> | void;\n  let hasChanged = InMemoryData.currentForeignData;\n  const output = InMemoryData.makeData(input);\n  while ((node = iterate())) {\n    const fieldAlias = getFieldAlias(node);\n    const fieldValue = input[fieldAlias];\n    // Add the current alias to the walked path before processing the field's value\n    ctx.__internal.path.push(fieldAlias);\n    // We temporarily store the data field in here, but undefined\n    // means that the value is missing from the cache\n    let dataFieldValue: void | DataField;\n    if (node.selectionSet && fieldValue !== null) {\n      dataFieldValue = readRootField(\n        ctx,\n        getSelectionSet(node),\n        ensureData(fieldValue)\n      );\n    } else {\n      dataFieldValue = fieldValue;\n    }\n\n    // Check for any referential changes in the field's value\n    hasChanged = hasChanged || dataFieldValue !== fieldValue;\n    if (dataFieldValue !== undefined) output[fieldAlias] = dataFieldValue!;\n\n    // After processing the field, remove the current alias from the path again\n    ctx.__internal.path.pop();\n  }\n\n  return hasChanged ? output : input;\n};\n\nconst readRootField = (\n  ctx: Context,\n  select: FormattedNode<SelectionSet>,\n  originalData: Link<Data>\n): Link<Data> => {\n  if (Array.isArray(originalData)) {\n    const newData = new Array(originalData.length);\n    let hasChanged = InMemoryData.currentForeignData;\n    for (let i = 0, l = originalData.length; i < l; i++) {\n      // Add the current index to the walked path before reading the field's value\n      ctx.__internal.path.push(i);\n      // Recursively read the root field's value\n      newData[i] = readRootField(ctx, select, originalData[i]);\n      hasChanged = hasChanged || newData[i] !== originalData[i];\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n    }\n\n    return hasChanged ? newData : originalData;\n  } else if (originalData === null) {\n    return null;\n  }\n\n  // Write entity to key that falls back to the given parentFieldKey\n  const entityKey = ctx.store.keyOfEntity(originalData);\n  if (entityKey !== null) {\n    // We assume that since this is used for result data this can never be undefined,\n    // since the result data has already been written to the cache\n    return readSelection(ctx, entityKey, select, originalData) || null;\n  } else {\n    return readRoot(ctx, originalData.__typename, select, originalData);\n  }\n};\n\nexport const _queryFragment = (\n  store: Store,\n  query: FormattedNode<DocumentNode>,\n  entity: Partial<Data> | string,\n  variables?: Variables,\n  fragmentName?: string\n): Data | null => {\n  const fragments = getFragments(query);\n\n  let fragment: FormattedNode<FragmentDefinitionNode>;\n  if (fragmentName) {\n    fragment = fragments[fragmentName]!;\n    if (!fragment) {\n      warn(\n        'readFragment(...) was called with a fragment name that does not exist.\\n' +\n          'You provided ' +\n          fragmentName +\n          ' but could only find ' +\n          Object.keys(fragments).join(', ') +\n          '.',\n        6,\n        store.logger\n      );\n\n      return null;\n    }\n  } else {\n    const names = Object.keys(fragments);\n    fragment = fragments[names[0]]!;\n    if (!fragment) {\n      warn(\n        'readFragment(...) was called with an empty fragment.\\n' +\n          'You have to call it with at least one fragment in your GraphQL document.',\n        6,\n        store.logger\n      );\n\n      return null;\n    }\n  }\n\n  const typename = getFragmentTypeName(fragment);\n  if (typeof entity !== 'string' && !entity.__typename)\n    entity.__typename = typename;\n  const entityKey = store.keyOfEntity(entity as Data);\n  if (!entityKey) {\n    warn(\n      \"Can't generate a key for readFragment(...).\\n\" +\n        'You have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        typename +\n        '`.',\n      7,\n      store.logger\n    );\n\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(typename, fragment);\n  }\n\n  const ctx = makeContext(\n    store,\n    variables || {},\n    fragments,\n    typename,\n    entityKey,\n    undefined\n  );\n\n  const result =\n    readSelection(\n      ctx,\n      entityKey,\n      getSelectionSet(fragment),\n      InMemoryData.makeData()\n    ) || null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n  }\n\n  return result;\n};\n\nfunction getFieldResolver(\n  directives: ReturnType<typeof getDirectives>,\n  typename: string,\n  fieldName: string,\n  ctx: Context\n): Resolver | void {\n  const resolvers = ctx.store.resolvers[typename];\n  const fieldResolver = resolvers && resolvers[fieldName];\n\n  let directiveResolver: Resolver | undefined;\n  for (const name in directives) {\n    const directiveNode = directives[name];\n    if (\n      directiveNode &&\n      name !== 'include' &&\n      name !== 'skip' &&\n      ctx.store.directives[name]\n    ) {\n      directiveResolver = ctx.store.directives[name](\n        getFieldArguments(directiveNode, ctx.variables)\n      );\n      if (process.env.NODE_ENV === 'production') return directiveResolver;\n      break;\n    }\n  }\n\n  if (fieldResolver && directiveResolver) {\n    warn(\n      `A resolver and directive is being used at \"${typename}.${fieldName}\" simultaneously. Only the directive will apply.`,\n      28,\n      ctx.store.logger\n    );\n  }\n\n  return directiveResolver || fieldResolver;\n}\n\nconst readSelection = (\n  ctx: Context,\n  key: string,\n  select: FormattedNode<SelectionSet>,\n  input: Data,\n  result?: Data\n): Data | undefined => {\n  const { store } = ctx;\n  const isQuery = key === store.rootFields.query;\n\n  const entityKey = (result && store.keyOfEntity(result)) || key;\n  if (!isQuery && !!ctx.store.rootNames[entityKey]) {\n    warn(\n      'Invalid root traversal: A selection was being read on `' +\n        entityKey +\n        '` which is an uncached root type.\\n' +\n        'The `' +\n        ctx.store.rootFields.mutation +\n        '` and `' +\n        ctx.store.rootFields.subscription +\n        '` types are special ' +\n        'Operation Root Types and cannot be read back from the cache.',\n      25,\n      store.logger\n    );\n  }\n\n  const typename = !isQuery\n    ? InMemoryData.readRecord(entityKey, '__typename') ||\n      (result && result.__typename)\n    : key;\n\n  if (typeof typename !== 'string') {\n    return;\n  } else if (result && typename !== result.__typename) {\n    warn(\n      'Invalid resolver data: The resolver at `' +\n        entityKey +\n        '` returned an ' +\n        'invalid typename that could not be reconciled with the cache.',\n      8,\n      store.logger\n    );\n\n    return;\n  }\n\n  const iterate = makeSelectionIterator(\n    typename,\n    entityKey,\n    false,\n    undefined,\n    select,\n    ctx\n  );\n\n  let hasFields = false;\n  let hasNext = false;\n  let hasChanged = InMemoryData.currentForeignData;\n  let node: FormattedNode<FieldNode> | void;\n  const hasPartials = ctx.partial;\n  const output = InMemoryData.makeData(input);\n  while ((node = iterate()) !== undefined) {\n    // Derive the needed data from our node.\n    const fieldName = getName(node);\n    const fieldArgs = getFieldArguments(node, ctx.variables);\n    const fieldAlias = getFieldAlias(node);\n    const directives = getDirectives(node);\n    const resolver = getFieldResolver(directives, typename, fieldName, ctx);\n    const fieldKey = keyOfField(fieldName, fieldArgs);\n    const key = joinKeys(entityKey, fieldKey);\n    const fieldValue = InMemoryData.readRecord(entityKey, fieldKey);\n    const resultValue = result ? result[fieldName] : undefined;\n\n    if (process.env.NODE_ENV !== 'production' && store.schema && typename) {\n      isFieldAvailableOnType(\n        store.schema,\n        typename,\n        fieldName,\n        ctx.store.logger\n      );\n    }\n\n    // Add the current alias to the walked path before processing the field's value\n    ctx.__internal.path.push(fieldAlias);\n    // We temporarily store the data field in here, but undefined\n    // means that the value is missing from the cache\n    let dataFieldValue: void | DataField = undefined;\n\n    if (fieldName === '__typename') {\n      // We directly assign the typename as it's already available\n      dataFieldValue = typename;\n    } else if (resultValue !== undefined && node.selectionSet === undefined) {\n      // The field is a scalar and can be retrieved directly from the result\n      dataFieldValue = resultValue;\n    } else if (InMemoryData.currentOperation === 'read' && resolver) {\n      // We have a resolver for this field.\n      // Prepare the actual fieldValue, so that the resolver can use it,\n      // as to avoid the user having to do `cache.resolve(parent, info.fieldKey)`\n      // only to get a scalar value.\n      let parent = output;\n      if (node.selectionSet === undefined && fieldValue !== undefined) {\n        parent = {\n          ...output,\n          [fieldAlias]: fieldValue,\n          [fieldName]: fieldValue,\n        };\n      }\n\n      // We have to update the information in context to reflect the info\n      // that the resolver will receive\n      updateContext(ctx, parent, typename, entityKey, fieldKey, fieldName);\n\n      dataFieldValue = resolver(\n        parent,\n        fieldArgs || ({} as Variables),\n        store,\n        ctx\n      );\n\n      if (node.selectionSet) {\n        // When it has a selection set we are resolving an entity with a\n        // subselection. This can either be a list or an object.\n        dataFieldValue = resolveResolverResult(\n          ctx,\n          typename,\n          fieldName,\n          key,\n          getSelectionSet(node),\n          (output[fieldAlias] !== undefined\n            ? output[fieldAlias]\n            : input[fieldAlias]) as Data,\n          dataFieldValue,\n          InMemoryData.ownsData(input)\n        );\n      }\n\n      if (\n        store.schema &&\n        dataFieldValue === null &&\n        !isFieldNullable(store.schema, typename, fieldName, ctx.store.logger)\n      ) {\n        // Special case for when null is not a valid value for the\n        // current field\n        return undefined;\n      }\n    } else if (!node.selectionSet) {\n      // The field is a scalar but isn't on the result, so it's retrieved from the cache\n      dataFieldValue = fieldValue;\n    } else if (resultValue !== undefined) {\n      // We start walking the nested resolver result here\n      dataFieldValue = resolveResolverResult(\n        ctx,\n        typename,\n        fieldName,\n        key,\n        getSelectionSet(node),\n        (output[fieldAlias] !== undefined\n          ? output[fieldAlias]\n          : input[fieldAlias]) as Data,\n        resultValue,\n        InMemoryData.ownsData(input)\n      );\n    } else {\n      // Otherwise we attempt to get the missing field from the cache\n      const link = InMemoryData.readLink(entityKey, fieldKey);\n\n      if (link !== undefined) {\n        dataFieldValue = resolveLink(\n          ctx,\n          link,\n          typename,\n          fieldName,\n          getSelectionSet(node),\n          (output[fieldAlias] !== undefined\n            ? output[fieldAlias]\n            : input[fieldAlias]) as Data,\n          InMemoryData.ownsData(input)\n        );\n      } else if (typeof fieldValue === 'object' && fieldValue !== null) {\n        // The entity on the field was invalid but can still be recovered\n        dataFieldValue = fieldValue;\n      }\n    }\n\n    // Now that dataFieldValue has been retrieved it'll be set on data\n    // If it's uncached (undefined) but nullable we can continue assembling\n    // a partial query result\n    if (\n      !deferRef &&\n      dataFieldValue === undefined &&\n      (directives.optional ||\n        (optionalRef && !directives.required) ||\n        !!getFieldError(ctx) ||\n        (store.schema &&\n          isFieldNullable(store.schema, typename, fieldName, ctx.store.logger)))\n    ) {\n      // The field is uncached or has errored, so it'll be set to null and skipped\n      ctx.partial = true;\n      dataFieldValue = null;\n    } else if (\n      dataFieldValue === null &&\n      (directives.required || optionalRef === false)\n    ) {\n      if (\n        ctx.store.logger &&\n        process.env.NODE_ENV !== 'production' &&\n        InMemoryData.currentOperation === 'read'\n      ) {\n        ctx.store.logger(\n          'debug',\n          `Got value \"null\" for required field \"${fieldName}\"${\n            fieldArgs ? ` with args ${JSON.stringify(fieldArgs)}` : ''\n          } on entity \"${entityKey}\"`\n        );\n      }\n      dataFieldValue = undefined;\n    } else {\n      hasFields = hasFields || fieldName !== '__typename';\n    }\n\n    // After processing the field, remove the current alias from the path again\n    ctx.__internal.path.pop();\n    // Check for any referential changes in the field's value\n    hasChanged = hasChanged || dataFieldValue !== input[fieldAlias];\n    if (dataFieldValue !== undefined) {\n      output[fieldAlias] = dataFieldValue;\n    } else if (deferRef) {\n      hasNext = true;\n    } else {\n      if (\n        ctx.store.logger &&\n        process.env.NODE_ENV !== 'production' &&\n        InMemoryData.currentOperation === 'read'\n      ) {\n        ctx.store.logger(\n          'debug',\n          `No value for field \"${fieldName}\"${\n            fieldArgs ? ` with args ${JSON.stringify(fieldArgs)}` : ''\n          } on entity \"${entityKey}\"`\n        );\n      }\n      // If the field isn't deferred or partial then we have to abort and also reset\n      // the partial field\n      ctx.partial = hasPartials;\n      return undefined;\n    }\n  }\n\n  ctx.partial = ctx.partial || hasPartials;\n  ctx.hasNext = ctx.hasNext || hasNext;\n  return isQuery && ctx.partial && !hasFields\n    ? undefined\n    : hasChanged\n    ? output\n    : input;\n};\n\nconst resolveResolverResult = (\n  ctx: Context,\n  typename: string,\n  fieldName: string,\n  key: string,\n  select: FormattedNode<SelectionSet>,\n  prevData: void | null | Data | Data[],\n  result: void | DataField,\n  isOwnedData: boolean\n): DataField | void => {\n  if (Array.isArray(result)) {\n    const { store } = ctx;\n    // Check whether values of the list may be null; for resolvers we assume\n    // that they can be, since it's user-provided data\n    const _isListNullable = store.schema\n      ? isListNullable(store.schema, typename, fieldName, ctx.store.logger)\n      : false;\n    const hasPartials = ctx.partial;\n    const data = InMemoryData.makeData(prevData, true);\n    let hasChanged =\n      InMemoryData.currentForeignData ||\n      !Array.isArray(prevData) ||\n      result.length !== prevData.length;\n    for (let i = 0, l = result.length; i < l; i++) {\n      // Add the current index to the walked path before reading the field's value\n      ctx.__internal.path.push(i);\n      // Recursively read resolver result\n      const childResult = resolveResolverResult(\n        ctx,\n        typename,\n        fieldName,\n        joinKeys(key, `${i}`),\n        select,\n        prevData != null ? prevData[i] : undefined,\n        result[i],\n        isOwnedData\n      );\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n      // Check the result for cache-missed values\n      if (childResult === undefined && !_isListNullable) {\n        ctx.partial = hasPartials;\n        return undefined;\n      } else {\n        ctx.partial =\n          ctx.partial || (childResult === undefined && _isListNullable);\n        data[i] = childResult != null ? childResult : null;\n        hasChanged = hasChanged || data[i] !== prevData![i];\n      }\n    }\n\n    return hasChanged ? data : prevData;\n  } else if (result === null || result === undefined) {\n    return result;\n  } else if (isOwnedData && prevData === null) {\n    return null;\n  } else if (isDataOrKey(result)) {\n    const data = (prevData || InMemoryData.makeData(prevData)) as Data;\n    return typeof result === 'string'\n      ? readSelection(ctx, result, select, data)\n      : readSelection(ctx, key, select, data, result);\n  } else {\n    warn(\n      'Invalid resolver value: The field at `' +\n        key +\n        '` is a scalar (number, boolean, etc)' +\n        ', but the GraphQL query expects a selection set for this field.',\n      9,\n      ctx.store.logger\n    );\n\n    return undefined;\n  }\n};\n\nconst resolveLink = (\n  ctx: Context,\n  link: Link | Link[],\n  typename: string,\n  fieldName: string,\n  select: FormattedNode<SelectionSet>,\n  prevData: void | null | Data | Data[],\n  isOwnedData: boolean\n): DataField | undefined => {\n  if (Array.isArray(link)) {\n    const { store } = ctx;\n    const _isListNullable = store.schema\n      ? isListNullable(store.schema, typename, fieldName, ctx.store.logger)\n      : false;\n    const newLink = InMemoryData.makeData(prevData, true);\n    const hasPartials = ctx.partial;\n    let hasChanged =\n      InMemoryData.currentForeignData ||\n      !Array.isArray(prevData) ||\n      link.length !== prevData.length;\n    for (let i = 0, l = link.length; i < l; i++) {\n      // Add the current index to the walked path before reading the field's value\n      ctx.__internal.path.push(i);\n      // Recursively read the link\n      const childLink = resolveLink(\n        ctx,\n        link[i],\n        typename,\n        fieldName,\n        select,\n        prevData != null ? prevData[i] : undefined,\n        isOwnedData\n      );\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n      // Check the result for cache-missed values\n      if (childLink === undefined && !_isListNullable) {\n        ctx.partial = hasPartials;\n        return undefined;\n      } else {\n        ctx.partial =\n          ctx.partial || (childLink === undefined && _isListNullable);\n        newLink[i] = childLink || null;\n        hasChanged = hasChanged || newLink[i] !== prevData![i];\n      }\n    }\n\n    return hasChanged ? newLink : (prevData as Data[]);\n  } else if (link === null || (prevData === null && isOwnedData)) {\n    return null;\n  }\n\n  return readSelection(\n    ctx,\n    link,\n    select,\n    (prevData || InMemoryData.makeData(prevData)) as Data\n  );\n};\n\nconst isDataOrKey = (x: any): x is string | Data =>\n  typeof x === 'string' ||\n  (typeof x === 'object' && typeof (x as any).__typename === 'string');\n","import * as InMemoryData from '../store/data';\nimport { keyOfField } from '../store/keys';\nimport type { FieldArgs } from '../types';\n\ninterface PartialFieldInfo {\n  fieldKey: string;\n}\n\nexport const invalidateEntity = (\n  entityKey: string,\n  field?: string,\n  args?: FieldArgs\n) => {\n  const fields: PartialFieldInfo[] = field\n    ? [{ fieldKey: keyOfField(field, args) }]\n    : InMemoryData.inspectFields(entityKey);\n\n  for (let i = 0, l = fields.length; i < l; i++) {\n    const { fieldKey } = fields[i];\n    if (InMemoryData.readLink(entityKey, fieldKey) !== undefined) {\n      InMemoryData.writeLink(entityKey, fieldKey, undefined);\n    } else {\n      InMemoryData.writeRecord(entityKey, fieldKey, undefined);\n    }\n  }\n};\n\nexport const invalidateType = (\n  typename: string,\n  excludedEntities: string[]\n) => {\n  const types = InMemoryData.getEntitiesForType(typename);\n  for (const entity of types) {\n    if (excludedEntities.includes(entity)) continue;\n    invalidateEntity(entity);\n  }\n};\n","import type { FormattedNode, CombinedError } from '@urql/core';\nimport { formatDocument } from '@urql/core';\n\nimport type {\n  FieldNode,\n  DocumentNode,\n  FragmentDefinitionNode,\n} from '@0no-co/graphql.web';\n\nimport type { SelectionSet } from '../ast';\nimport {\n  getFragments,\n  getMainOperation,\n  normalizeVariables,\n  getFieldArguments,\n  isFieldAvailableOnType,\n  getSelectionSet,\n  getName,\n  getFragmentTypeName,\n  getFieldAlias,\n} from '../ast';\n\nimport { invariant, warn, pushDebugNode, popDebugNode } from '../helpers/help';\n\nimport type {\n  NullArray,\n  Variables,\n  Data,\n  Link,\n  OperationRequest,\n  Dependencies,\n  EntityField,\n  OptimisticMutationResolver,\n} from '../types';\n\nimport { joinKeys, keyOfField } from '../store/keys';\nimport type { Store } from '../store/store';\nimport * as InMemoryData from '../store/data';\n\nimport type { Context } from './shared';\nimport {\n  makeSelectionIterator,\n  ensureData,\n  makeContext,\n  updateContext,\n  getFieldError,\n  deferRef,\n} from './shared';\nimport { invalidateType } from './invalidate';\n\nexport interface WriteResult {\n  data: null | Data;\n  dependencies: Dependencies;\n}\n\n/** Writes a GraphQL response to the cache.\n * @internal\n */\nexport const __initAnd_write = (\n  store: Store,\n  request: OperationRequest,\n  data: Data,\n  error?: CombinedError | undefined,\n  key?: number\n): WriteResult => {\n  InMemoryData.initDataState('write', store.data, key || null);\n  const result = _write(store, request, data, error);\n  InMemoryData.clearDataState();\n  return result;\n};\n\nexport const __initAnd_writeOptimistic = (\n  store: Store,\n  request: OperationRequest,\n  key: number\n): WriteResult => {\n  if (process.env.NODE_ENV !== 'production') {\n    invariant(\n      getMainOperation(request.query).operation === 'mutation',\n      'writeOptimistic(...) was called with an operation that is not a mutation.\\n' +\n        'This case is unsupported and should never occur.',\n      10\n    );\n  }\n\n  InMemoryData.initDataState('write', store.data, key, true);\n  const result = _write(store, request, {} as Data, undefined);\n  InMemoryData.clearDataState();\n  return result;\n};\n\nexport const _write = (\n  store: Store,\n  request: OperationRequest,\n  data?: Data,\n  error?: CombinedError | undefined\n) => {\n  if (process.env.NODE_ENV !== 'production') {\n    InMemoryData.getCurrentDependencies();\n  }\n\n  const query = formatDocument(request.query);\n  const operation = getMainOperation(query);\n  const result: WriteResult = {\n    data: data || InMemoryData.makeData(),\n    dependencies: InMemoryData.currentDependencies!,\n  };\n  const kind = store.rootFields[operation.operation];\n\n  const ctx = makeContext(\n    store,\n    normalizeVariables(operation, request.variables),\n    getFragments(query),\n    kind,\n    kind,\n    error\n  );\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(kind, operation);\n  }\n\n  writeSelection(ctx, kind, getSelectionSet(operation), result.data!);\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n  }\n\n  return result;\n};\n\nexport const _writeFragment = (\n  store: Store,\n  query: FormattedNode<DocumentNode>,\n  data: Partial<Data>,\n  variables?: Variables,\n  fragmentName?: string\n) => {\n  const fragments = getFragments(query);\n  let fragment: FormattedNode<FragmentDefinitionNode>;\n  if (fragmentName) {\n    fragment = fragments[fragmentName]!;\n    if (!fragment) {\n      warn(\n        'writeFragment(...) was called with a fragment name that does not exist.\\n' +\n          'You provided ' +\n          fragmentName +\n          ' but could only find ' +\n          Object.keys(fragments).join(', ') +\n          '.',\n        11,\n        store.logger\n      );\n\n      return null;\n    }\n  } else {\n    const names = Object.keys(fragments);\n    fragment = fragments[names[0]]!;\n    if (!fragment) {\n      warn(\n        'writeFragment(...) was called with an empty fragment.\\n' +\n          'You have to call it with at least one fragment in your GraphQL document.',\n        11,\n        store.logger\n      );\n\n      return null;\n    }\n  }\n\n  const typename = getFragmentTypeName(fragment);\n  const dataToWrite = { __typename: typename, ...data } as Data;\n  const entityKey = store.keyOfEntity(dataToWrite);\n  if (!entityKey) {\n    return warn(\n      \"Can't generate a key for writeFragment(...) data.\\n\" +\n        'You have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        typename +\n        '`.',\n      12,\n      store.logger\n    );\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(typename, fragment);\n  }\n\n  const ctx = makeContext(\n    store,\n    variables || {},\n    fragments,\n    typename,\n    entityKey,\n    undefined\n  );\n\n  writeSelection(ctx, entityKey, getSelectionSet(fragment), dataToWrite);\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n  }\n};\n\nconst writeSelection = (\n  ctx: Context,\n  entityKey: undefined | string,\n  select: FormattedNode<SelectionSet>,\n  data: Data\n) => {\n  // These fields determine how we write. The `Query` root type is written\n  // like a normal entity, hence, we use `rootField` with a default to determine\n  // this. All other root names (Subscription & Mutation) are in a different\n  // write mode\n  const rootField = ctx.store.rootNames[entityKey!] || 'query';\n  const isRoot = !!ctx.store.rootNames[entityKey!];\n\n  let typename = isRoot ? entityKey : data.__typename;\n  if (!typename && entityKey && ctx.optimistic) {\n    typename = InMemoryData.readRecord(entityKey, '__typename') as\n      | string\n      | undefined;\n  }\n\n  if (!typename) {\n    warn(\n      \"Couldn't find __typename when writing.\\n\" +\n        \"If you're writing to the cache manually have to pass a `__typename` property on each entity in your data.\",\n      14,\n      ctx.store.logger\n    );\n    return;\n  } else if (!isRoot && entityKey) {\n    InMemoryData.writeRecord(entityKey, '__typename', typename);\n    InMemoryData.writeType(typename, entityKey);\n  }\n\n  const updates = ctx.store.updates[typename];\n  const iterate = makeSelectionIterator(\n    typename,\n    entityKey || typename,\n    false,\n    undefined,\n    select,\n    ctx\n  );\n\n  let node: FormattedNode<FieldNode> | void;\n  while ((node = iterate())) {\n    const fieldName = getName(node);\n    const fieldArgs = getFieldArguments(node, ctx.variables);\n    const fieldKey = keyOfField(fieldName, fieldArgs);\n    const fieldAlias = getFieldAlias(node);\n    let fieldValue = data[ctx.optimistic ? fieldName : fieldAlias];\n\n    if (\n      // Skip typename fields and assume they've already been written above\n      fieldName === '__typename' ||\n      // Fields marked as deferred that aren't defined must be skipped\n      // Otherwise, we also ignore undefined values in optimistic updaters\n      (fieldValue === undefined &&\n        (deferRef || (ctx.optimistic && rootField === 'query')))\n    ) {\n      continue;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (ctx.store.schema && typename && fieldName !== '__typename') {\n        isFieldAvailableOnType(\n          ctx.store.schema,\n          typename,\n          fieldName,\n          ctx.store.logger\n        );\n      }\n    }\n\n    // Add the current alias to the walked path before processing the field's value\n    ctx.__internal.path.push(fieldAlias);\n\n    // Execute optimistic mutation functions on root fields, or execute recursive functions\n    // that have been returned on optimistic objects\n    let resolver: OptimisticMutationResolver | undefined;\n    if (ctx.optimistic && rootField === 'mutation') {\n      resolver = ctx.store.optimisticMutations[fieldName];\n      if (!resolver) continue;\n    } else if (ctx.optimistic && typeof fieldValue === 'function') {\n      resolver = fieldValue as any;\n    }\n\n    // Execute the field-level resolver to retrieve its data\n    if (resolver) {\n      // We have to update the context to reflect up-to-date ResolveInfo\n      updateContext(\n        ctx,\n        data,\n        typename,\n        entityKey || typename,\n        fieldKey,\n        fieldName\n      );\n      fieldValue = ensureData(resolver(fieldArgs || {}, ctx.store, ctx));\n    }\n\n    if (fieldValue === undefined) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (\n          !entityKey ||\n          !InMemoryData.hasField(entityKey, fieldKey) ||\n          (ctx.optimistic && !InMemoryData.readRecord(entityKey, '__typename'))\n        ) {\n          const expected =\n            node.selectionSet === undefined\n              ? 'scalar (number, boolean, etc)'\n              : 'selection set';\n\n          warn(\n            'Invalid undefined: The field at `' +\n              fieldKey +\n              '` is `undefined`, but the GraphQL query expects a ' +\n              expected +\n              ' for this field.',\n            13,\n            ctx.store.logger\n          );\n        }\n      }\n\n      continue; // Skip this field\n    }\n\n    if (node.selectionSet) {\n      // Process the field and write links for the child entities that have been written\n      if (entityKey && rootField === 'query') {\n        const key = joinKeys(entityKey, fieldKey);\n        const link = writeField(\n          ctx,\n          getSelectionSet(node),\n          ensureData(fieldValue),\n          key,\n          ctx.optimistic\n            ? InMemoryData.readLink(entityKey || typename, fieldKey)\n            : undefined\n        );\n\n        InMemoryData.writeLink(entityKey || typename, fieldKey, link);\n      } else {\n        writeField(ctx, getSelectionSet(node), ensureData(fieldValue));\n      }\n    } else if (entityKey && rootField === 'query') {\n      // This is a leaf node, so we're setting the field's value directly\n      InMemoryData.writeRecord(\n        entityKey || typename,\n        fieldKey,\n        (fieldValue !== null || !getFieldError(ctx)\n          ? fieldValue\n          : undefined) as EntityField\n      );\n    }\n\n    // We run side-effect updates after the default, normalized updates\n    // so that the data is already available in-store if necessary\n    const updater = updates && updates[fieldName];\n    if (updater) {\n      // We have to update the context to reflect up-to-date ResolveInfo\n      updateContext(\n        ctx,\n        data,\n        typename,\n        entityKey || typename,\n        fieldKey,\n        fieldName\n      );\n\n      data[fieldName] = fieldValue;\n      updater(data, fieldArgs || {}, ctx.store, ctx);\n    } else if (\n      typename === ctx.store.rootFields['mutation'] &&\n      !ctx.optimistic\n    ) {\n      // If we're on a mutation that doesn't have an updater, we'll see\n      // whether we can find the entity returned by the mutation in the cache.\n      // if we don't we'll assume this is a create mutation and invalidate\n      // the found __typename.\n      if (fieldValue && Array.isArray(fieldValue)) {\n        const excludedEntities: string[] = fieldValue.map(\n          entity => ctx.store.keyOfEntity(entity) || ''\n        );\n        for (let i = 0, l = fieldValue.length; i < l; i++) {\n          const key = excludedEntities[i];\n          if (key && fieldValue[i].__typename) {\n            const resolved = InMemoryData.readRecord(key, '__typename');\n            const count = InMemoryData!.getRefCount(key);\n            if (resolved && !count) {\n              invalidateType(fieldValue[i].__typename, excludedEntities);\n            }\n          }\n        }\n      } else if (fieldValue && typeof fieldValue === 'object') {\n        const key = ctx.store.keyOfEntity(fieldValue as any);\n        if (key) {\n          const resolved = InMemoryData.readRecord(key, '__typename');\n          const count = InMemoryData.getRefCount(key);\n          if ((!resolved || !count) && fieldValue.__typename) {\n            invalidateType(fieldValue.__typename, [key]);\n          }\n        }\n      }\n    }\n\n    // After processing the field, remove the current alias from the path again\n    ctx.__internal.path.pop();\n  }\n};\n\n// A pattern to match typenames of types that are likely never keyable\nconst KEYLESS_TYPE_RE = /^__|PageInfo|(Connection|Edge)$/;\n\nconst writeField = (\n  ctx: Context,\n  select: FormattedNode<SelectionSet>,\n  data: null | Data | NullArray<Data>,\n  parentFieldKey?: string,\n  prevLink?: Link\n): Link | undefined => {\n  if (Array.isArray(data)) {\n    const newData = new Array(data.length);\n    for (let i = 0, l = data.length; i < l; i++) {\n      // Add the current index to the walked path before processing the link\n      ctx.__internal.path.push(i);\n      // Append the current index to the parentFieldKey fallback\n      const indexKey = parentFieldKey\n        ? joinKeys(parentFieldKey, `${i}`)\n        : undefined;\n      // Recursively write array data\n      const prevIndex = prevLink != null ? prevLink[i] : undefined;\n      const links = writeField(ctx, select, data[i], indexKey, prevIndex);\n      // Link cannot be expressed as a recursive type\n      newData[i] = links as string | null;\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n    }\n\n    return newData;\n  } else if (data === null) {\n    return getFieldError(ctx) ? undefined : null;\n  }\n\n  const entityKey =\n    ctx.store.keyOfEntity(data) ||\n    (typeof prevLink === 'string' ? prevLink : null);\n  const typename = data.__typename;\n\n  if (\n    parentFieldKey &&\n    !ctx.store.keys[data.__typename] &&\n    entityKey === null &&\n    typeof typename === 'string' &&\n    !KEYLESS_TYPE_RE.test(typename)\n  ) {\n    warn(\n      'Invalid key: The GraphQL query at the field at `' +\n        parentFieldKey +\n        '` has a selection set, ' +\n        'but no key could be generated for the data at this field.\\n' +\n        'You have to request `id` or `_id` fields for all selection sets or create ' +\n        'a custom `keys` config for `' +\n        typename +\n        '`.\\n' +\n        'Entities without keys will be embedded directly on the parent entity. ' +\n        'If this is intentional, create a `keys` config for `' +\n        typename +\n        '` that always returns null.',\n      15,\n      ctx.store.logger\n    );\n  }\n\n  const childKey = entityKey || parentFieldKey;\n  writeSelection(ctx, childKey, select, data);\n  return childKey || null;\n};\n","import type { TypedDocumentNode } from '@urql/core';\nimport { formatDocument, createRequest } from '@urql/core';\n\nimport type {\n  Cache,\n  FieldInfo,\n  ResolverConfig,\n  DataField,\n  Variables,\n  FieldArgs,\n  Link,\n  Data,\n  QueryInput,\n  UpdatesConfig,\n  OptimisticMutationConfig,\n  KeyingConfig,\n  Entity,\n  CacheExchangeOpts,\n  DirectivesConfig,\n  Logger,\n} from '../types';\n\nimport { invariant } from '../helpers/help';\nimport { contextRef, ensureLink } from '../operations/shared';\nimport { _query, _queryFragment } from '../operations/query';\nimport { _write, _writeFragment } from '../operations/write';\nimport { invalidateEntity, invalidateType } from '../operations/invalidate';\nimport { keyOfField } from './keys';\nimport * as InMemoryData from './data';\n\nimport type { SchemaIntrospector } from '../ast';\nimport {\n  buildClientSchema,\n  expectValidKeyingConfig,\n  expectValidUpdatesConfig,\n  expectValidResolversConfig,\n  expectValidOptimisticMutationsConfig,\n} from '../ast';\n\ntype DocumentNode = TypedDocumentNode<any, any>;\ntype RootField = 'query' | 'mutation' | 'subscription';\n\n/** Implementation of the {@link Cache} interface as created internally by the {@link cacheExchange}.\n * @internal\n */\nexport class Store<\n  C extends Partial<CacheExchangeOpts> = Partial<CacheExchangeOpts>,\n> implements Cache\n{\n  data: InMemoryData.InMemoryData;\n\n  logger?: Logger;\n  directives: DirectivesConfig;\n  resolvers: ResolverConfig;\n  updates: UpdatesConfig;\n  optimisticMutations: OptimisticMutationConfig;\n  keys: KeyingConfig;\n  globalIDs: Set<string> | boolean;\n  schema?: SchemaIntrospector;\n\n  rootFields: { query: string; mutation: string; subscription: string };\n  rootNames: { [name: string]: RootField | void };\n\n  constructor(opts?: C) {\n    if (!opts) opts = {} as C;\n\n    this.logger = opts.logger;\n    this.resolvers = opts.resolvers || {};\n    this.directives = opts.directives || {};\n    this.optimisticMutations = opts.optimistic || {};\n    this.keys = opts.keys || {};\n\n    this.globalIDs = Array.isArray(opts.globalIDs)\n      ? new Set(opts.globalIDs)\n      : !!opts.globalIDs;\n\n    let queryName = 'Query';\n    let mutationName = 'Mutation';\n    let subscriptionName = 'Subscription';\n    if (opts.schema) {\n      const schema = buildClientSchema(opts.schema);\n      queryName = schema.query || queryName;\n      mutationName = schema.mutation || mutationName;\n      subscriptionName = schema.subscription || subscriptionName;\n      // Only add schema introspector if it has types info\n      if (schema.types) this.schema = schema;\n    }\n\n    this.updates = opts.updates || {};\n\n    this.rootFields = {\n      query: queryName,\n      mutation: mutationName,\n      subscription: subscriptionName,\n    };\n\n    this.rootNames = {\n      [queryName]: 'query',\n      [mutationName]: 'mutation',\n      [subscriptionName]: 'subscription',\n    };\n\n    this.data = InMemoryData.make(queryName);\n\n    if (this.schema && process.env.NODE_ENV !== 'production') {\n      expectValidKeyingConfig(this.schema, this.keys, this.logger);\n      expectValidUpdatesConfig(this.schema, this.updates, this.logger);\n      expectValidResolversConfig(this.schema, this.resolvers, this.logger);\n      expectValidOptimisticMutationsConfig(\n        this.schema,\n        this.optimisticMutations,\n        this.logger\n      );\n    }\n  }\n\n  keyOfField(fieldName: string, fieldArgs?: FieldArgs) {\n    return keyOfField(fieldName, fieldArgs);\n  }\n\n  keyOfEntity(data: Entity) {\n    // In resolvers and updaters we may have a specific parent\n    // object available that can be used to skip to a specific parent\n    // key directly without looking at its incomplete properties\n    if (contextRef && data === contextRef.parent) {\n      return contextRef.parentKey;\n    } else if (data == null || typeof data === 'string') {\n      return data || null;\n    } else if (!data.__typename) {\n      return null;\n    } else if (this.rootNames[data.__typename]) {\n      return data.__typename;\n    }\n\n    let key: string | null = null;\n    if (this.keys[data.__typename]) {\n      key = this.keys[data.__typename](data) || null;\n    } else if (data.id != null) {\n      key = `${data.id}`;\n    } else if (data._id != null) {\n      key = `${data._id}`;\n    }\n\n    const typename = data.__typename;\n    const globalID =\n      this.globalIDs === true ||\n      (this.globalIDs && this.globalIDs.has(typename));\n    return globalID || !key ? key : `${typename}:${key}`;\n  }\n\n  resolve(\n    entity: Entity,\n    field: string,\n    args?: FieldArgs\n  ): DataField | undefined {\n    const entityKey = this.keyOfEntity(entity);\n    if (entityKey) {\n      const fieldKey = keyOfField(field, args);\n      const fieldValue = InMemoryData.readRecord(entityKey, fieldKey);\n      if (fieldValue !== undefined) return fieldValue;\n      let fieldLink = InMemoryData.readLink(entityKey, fieldKey);\n      if (fieldLink !== undefined) fieldLink = ensureLink(this, fieldLink);\n      return fieldLink;\n    }\n  }\n\n  invalidate(entity: Entity, field?: string, args?: FieldArgs) {\n    const entityKey = this.keyOfEntity(entity);\n    const shouldInvalidateType =\n      entity &&\n      typeof entity === 'string' &&\n      !field &&\n      !args &&\n      !this.resolve(entity, '__typename');\n\n    if (shouldInvalidateType) {\n      invalidateType(entity, []);\n    } else {\n      invariant(\n        entityKey,\n        \"Can't generate a key for invalidate(...).\\n\" +\n          'You have to pass an id or _id field or create a custom `keys` field for `' +\n          (typeof entity === 'object'\n            ? (entity as Data).__typename\n            : entity + '`.'),\n        19\n      );\n\n      invalidateEntity(entityKey, field, args);\n    }\n  }\n\n  inspectFields(entity: Entity): FieldInfo[] {\n    const entityKey = this.keyOfEntity(entity);\n    return entityKey ? InMemoryData.inspectFields(entityKey) : [];\n  }\n\n  updateQuery<T = Data, V = Variables>(\n    input: QueryInput<T, V>,\n    updater: (data: T | null) => T | null\n  ): void {\n    const request = createRequest(input.query, input.variables!);\n    const output = updater(this.readQuery(request));\n    if (output !== null) {\n      _write(this, request, output as any, undefined);\n    }\n  }\n\n  readQuery<T = Data, V = Variables>(input: QueryInput<T, V>): T | null {\n    const request = createRequest(input.query, input.variables!);\n    return _query(this, request, undefined, undefined).data as T | null;\n  }\n\n  readFragment<T = Data, V = Variables>(\n    fragment: DocumentNode | TypedDocumentNode<T, V>,\n    entity: string | Data | T,\n    variables?: V,\n    fragmentName?: string\n  ): T | null {\n    return _queryFragment(\n      this,\n      formatDocument(fragment),\n      entity as Data,\n      variables as any,\n      fragmentName\n    ) as T | null;\n  }\n\n  writeFragment<T = Data, V = Variables>(\n    fragment: DocumentNode | TypedDocumentNode<T, V>,\n    data: T,\n    variables?: V,\n    fragmentName?: string\n  ): void {\n    _writeFragment(\n      this,\n      formatDocument(fragment),\n      data as Data,\n      variables as any,\n      fragmentName\n    );\n  }\n\n  link(\n    entity: Entity,\n    field: string,\n    args: FieldArgs,\n    link: Link<Entity>\n  ): void;\n\n  link(entity: Entity, field: string, link: Link<Entity>): void;\n\n  link(\n    entity: Entity,\n    field: string,\n    ...rest: [FieldArgs, Link<Entity>] | [Link<Entity>]\n  ): void {\n    const args = rest.length === 2 ? rest[0] : null;\n    const link = rest.length === 2 ? rest[1] : rest[0];\n    const entityKey = this.keyOfEntity(entity);\n    if (entityKey) {\n      InMemoryData.writeLink(\n        entityKey,\n        keyOfField(field, args),\n        ensureLink(this, link)\n      );\n    }\n  }\n}\n","import type { Operation, RequestPolicy, OperationDebugMeta } from '@urql/core';\nimport { makeOperation } from '@urql/core';\n\n// Returns the given operation result with added cacheOutcome meta field\nexport const addMetadata = (\n  operation: Operation,\n  meta: OperationDebugMeta\n): Operation =>\n  makeOperation(operation.kind, operation, {\n    ...operation.context,\n    meta: {\n      ...operation.context.meta,\n      ...meta,\n    },\n  });\n\n// Copy an operation and change the requestPolicy to skip the cache\nexport const toRequestPolicy = (\n  operation: Operation,\n  requestPolicy: RequestPolicy\n): Operation => {\n  return makeOperation(operation.kind, operation, {\n    ...operation.context,\n    requestPolicy,\n  });\n};\n","import type {\n  Exchange,\n  Operation,\n  OperationResult,\n  RequestPolicy,\n  CacheOutcome,\n} from '@urql/core';\nimport { formatDocument, makeOperation } from '@urql/core';\n\nimport type { Source } from 'wonka';\nimport {\n  filter,\n  map,\n  merge,\n  pipe,\n  share,\n  fromArray,\n  mergeMap,\n  empty,\n} from 'wonka';\n\nimport { _query } from './operations/query';\nimport { _write } from './operations/write';\nimport { addMetadata, toRequestPolicy } from './helpers/operation';\nimport { filterVariables, getMainOperation } from './ast';\nimport { Store } from './store/store';\nimport type { Data, Dependencies, CacheExchangeOpts } from './types';\n\nimport {\n  initDataState,\n  clearDataState,\n  noopDataState,\n  hydrateData,\n  reserveLayer,\n  hasLayer,\n} from './store/data';\n\ninterface OperationResultWithMeta extends Partial<OperationResult> {\n  operation: Operation;\n  outcome: CacheOutcome;\n  dependencies: Dependencies;\n  hasNext: boolean;\n}\n\ntype Operations = Set<number>;\ntype OperationMap = Map<number, Operation>;\ntype ResultMap = Map<number, Data | null>;\ntype OptimisticDependencies = Map<number, Dependencies>;\ntype DependentOperations = Map<string, Operations>;\n\n/** Exchange factory that creates a normalized cache exchange.\n *\n * @param opts - A {@link CacheExchangeOpts} configuration object.\n * @returns the created normalized cache {@link Exchange}.\n *\n * @remarks\n * Graphcache is a normalized cache, enabled by using the `cacheExchange`\n * in place of `@urql/core`s. A normalized GraphQL cache uses typenames\n * and key fields in the result to share a single copy for each unique\n * entity across all queries.\n *\n * The `cacheExchange` may be passed a {@link CacheExchangeOpts} object\n * to define custom resolvers, custom updates for mutations,\n * optimistic updates, or to add custom key fields per type.\n *\n * @see {@link https://urql.dev/goto/docs/graphcache} for the full Graphcache docs.\n */\nexport const cacheExchange =\n  <C extends Partial<CacheExchangeOpts>>(opts?: C): Exchange =>\n  ({ forward, client, dispatchDebug }) => {\n    const store = new Store<C>(opts);\n\n    if (opts && opts.storage) {\n      store.data.hydrating = true;\n      opts.storage.readData().then(entries => {\n        hydrateData(store.data, opts!.storage!, entries);\n        if (opts.storage!.onCacheHydrated) opts.storage!.onCacheHydrated();\n      });\n    }\n\n    const optimisticKeysToDependencies: OptimisticDependencies = new Map();\n    const mutationResultBuffer: OperationResult[] = [];\n    const operations: OperationMap = new Map();\n    const results: ResultMap = new Map();\n    const blockedDependencies: Dependencies = new Set();\n    const requestedRefetch: Operations = new Set();\n    const deps: DependentOperations = new Map();\n\n    let reexecutingOperations: Operations = new Set();\n    let dependentOperations: Operations = new Set();\n\n    const isBlockedByOptimisticUpdate = (\n      dependencies: Dependencies\n    ): boolean => {\n      for (const dep of dependencies.values())\n        if (blockedDependencies.has(dep)) return true;\n      return false;\n    };\n\n    const collectPendingOperations = (\n      pendingOperations: Operations,\n      dependencies: undefined | Dependencies\n    ) => {\n      if (dependencies) {\n        // Collect operations that will be updated due to cache changes\n        for (const dep of dependencies.values()) {\n          const keys = deps.get(dep);\n          if (keys) for (const key of keys.values()) pendingOperations.add(key);\n        }\n      }\n    };\n\n    const executePendingOperations = (\n      operation: Operation,\n      pendingOperations: Operations,\n      isOptimistic: boolean\n    ) => {\n      // Reexecute collected operations and delete them from the mapping\n      for (const key of pendingOperations.values()) {\n        if (key !== operation.key) {\n          const op = operations.get(key);\n          if (op) {\n            // Collect all dependent operations if the reexecuting operation is a query\n            if (operation.kind === 'query') dependentOperations.add(key);\n            let policy: RequestPolicy = 'cache-first';\n            if (requestedRefetch.has(key)) {\n              requestedRefetch.delete(key);\n              policy = 'cache-and-network';\n            }\n            client.reexecuteOperation(toRequestPolicy(op, policy));\n          }\n        }\n      }\n\n      if (!isOptimistic) {\n        // Upon completion, all dependent operations become reexecuting operations, preventing\n        // them from reexecuting prior operations again, causing infinite loops\n        const _reexecutingOperations = reexecutingOperations;\n        reexecutingOperations = dependentOperations;\n        if (operation.kind === 'query') {\n          reexecutingOperations.add(operation.key);\n        }\n        (dependentOperations = _reexecutingOperations).clear();\n      }\n    };\n\n    // This registers queries with the data layer to ensure commutativity\n    const prepareForwardedOperation = (operation: Operation) => {\n      let optimistic = false;\n      if (operation.kind === 'query') {\n        // Pre-reserve the position of the result layer\n        reserveLayer(store.data, operation.key);\n        operations.set(operation.key, operation);\n      } else if (operation.kind === 'teardown') {\n        // Delete reference to operation if any exists to release it\n        operations.delete(operation.key);\n        results.delete(operation.key);\n        reexecutingOperations.delete(operation.key);\n        // Mark operation layer as done\n        noopDataState(store.data, operation.key);\n        return operation;\n      } else if (\n        operation.kind === 'mutation' &&\n        operation.context.requestPolicy !== 'network-only'\n      ) {\n        operations.set(operation.key, operation);\n        // This executes an optimistic update for mutations and registers it if necessary\n        initDataState('write', store.data, operation.key, true, false);\n        const { dependencies } = _write(\n          store,\n          operation as any,\n          undefined,\n          undefined\n        );\n        clearDataState();\n        if (dependencies.size) {\n          // Update blocked optimistic dependencies\n          for (const dep of dependencies.values()) blockedDependencies.add(dep);\n          // Store optimistic dependencies for update\n          optimisticKeysToDependencies.set(operation.key, dependencies);\n          // Update related queries\n          const pendingOperations: Operations = new Set();\n          collectPendingOperations(pendingOperations, dependencies);\n          executePendingOperations(operation, pendingOperations, true);\n          // Mark operation as optimistic\n          optimistic = true;\n        }\n      }\n\n      return makeOperation(\n        operation.kind,\n        {\n          key: operation.key,\n          query: formatDocument(operation.query),\n          variables: operation.variables\n            ? filterVariables(\n                getMainOperation(operation.query),\n                operation.variables\n              )\n            : operation.variables,\n        },\n        { ...operation.context, optimistic }\n      );\n    };\n\n    // This updates the known dependencies for the passed operation\n    const updateDependencies = (op: Operation, dependencies: Dependencies) => {\n      for (const dep of dependencies.values()) {\n        let depOps = deps.get(dep);\n        if (!depOps) deps.set(dep, (depOps = new Set()));\n        depOps.add(op.key);\n      }\n    };\n\n    // Retrieves a query result from cache and adds an `isComplete` hint\n    // This hint indicates whether the result is \"complete\" or not\n    const operationResultFromCache = (\n      operation: Operation\n    ): OperationResultWithMeta => {\n      initDataState('read', store.data, undefined, false, false);\n      const result = _query(\n        store,\n        operation,\n        results.get(operation.key),\n        undefined\n      );\n      clearDataState();\n      const cacheOutcome: CacheOutcome = result.data\n        ? !result.partial && !result.hasNext\n          ? 'hit'\n          : 'partial'\n        : 'miss';\n\n      results.set(operation.key, result.data);\n      operations.set(operation.key, operation);\n      updateDependencies(operation, result.dependencies);\n\n      return {\n        outcome: cacheOutcome,\n        operation,\n        data: result.data,\n        dependencies: result.dependencies,\n        hasNext: result.hasNext,\n      };\n    };\n\n    // Take any OperationResult and update the cache with it\n    const updateCacheWithResult = (\n      result: OperationResult,\n      pendingOperations: Operations\n    ): OperationResult => {\n      // Retrieve the original operation to get unfiltered variables\n      const operation =\n        operations.get(result.operation.key) || result.operation;\n      if (operation.kind === 'mutation') {\n        // Collect previous dependencies that have been written for optimistic updates\n        const dependencies = optimisticKeysToDependencies.get(operation.key);\n        collectPendingOperations(pendingOperations, dependencies);\n        optimisticKeysToDependencies.delete(operation.key);\n      }\n\n      if (operation.kind === 'subscription' || result.hasNext)\n        reserveLayer(store.data, operation.key, true);\n\n      let queryDependencies: undefined | Dependencies;\n      let data: Data | null = result.data;\n      if (data) {\n        // Write the result to cache and collect all dependencies that need to be\n        // updated\n        initDataState('write', store.data, operation.key, false, false);\n        const writeDependencies = _write(\n          store,\n          operation,\n          data,\n          result.error\n        ).dependencies;\n        clearDataState();\n        collectPendingOperations(pendingOperations, writeDependencies);\n        const prevData =\n          operation.kind === 'query' ? results.get(operation.key) : null;\n        initDataState(\n          'read',\n          store.data,\n          operation.key,\n          false,\n          prevData !== data\n        );\n        const queryResult = _query(\n          store,\n          operation,\n          prevData || data,\n          result.error\n        );\n        clearDataState();\n        data = queryResult.data;\n        if (operation.kind === 'query') {\n          // Collect the query's dependencies for future pending operation updates\n          queryDependencies = queryResult.dependencies;\n          collectPendingOperations(pendingOperations, queryDependencies);\n          results.set(operation.key, data);\n        }\n      } else {\n        noopDataState(store.data, operation.key);\n      }\n\n      // Update this operation's dependencies if it's a query\n      if (queryDependencies) {\n        updateDependencies(result.operation, queryDependencies);\n      }\n\n      return {\n        operation,\n        data,\n        error: result.error,\n        extensions: result.extensions,\n        hasNext: result.hasNext,\n        stale: result.stale,\n      };\n    };\n\n    return operations$ => {\n      // Filter by operations that are cacheable and attempt to query them from the cache\n      const cacheOps$ = pipe(\n        operations$,\n        filter(\n          op =>\n            op.kind === 'query' && op.context.requestPolicy !== 'network-only'\n        ),\n        map(operationResultFromCache),\n        share\n      );\n\n      const nonCacheOps$ = pipe(\n        operations$,\n        filter(\n          op =>\n            op.kind !== 'query' || op.context.requestPolicy === 'network-only'\n        )\n      );\n\n      // Rebound operations that are incomplete, i.e. couldn't be queried just from the cache\n      const cacheMissOps$ = pipe(\n        cacheOps$,\n        filter(\n          res =>\n            res.outcome === 'miss' &&\n            res.operation.context.requestPolicy !== 'cache-only' &&\n            !isBlockedByOptimisticUpdate(res.dependencies) &&\n            !reexecutingOperations.has(res.operation.key)\n        ),\n        map(res => {\n          dispatchDebug({\n            type: 'cacheMiss',\n            message: 'The result could not be retrieved from the cache',\n            operation: res.operation,\n          });\n          return addMetadata(res.operation, { cacheOutcome: 'miss' });\n        })\n      );\n\n      // Resolve OperationResults that the cache was able to assemble completely and trigger\n      // a network request if the current operation's policy is cache-and-network\n      const cacheResult$ = pipe(\n        cacheOps$,\n        filter(\n          res =>\n            res.outcome !== 'miss' ||\n            res.operation.context.requestPolicy === 'cache-only'\n        ),\n        map((res: OperationResultWithMeta): OperationResult => {\n          const { requestPolicy } = res.operation.context;\n\n          // We reexecute requests marked as `cache-and-network`, and partial responses,\n          // if we wouldn't cause a request loop\n          const shouldReexecute =\n            requestPolicy !== 'cache-only' &&\n            (res.hasNext ||\n              requestPolicy === 'cache-and-network' ||\n              (requestPolicy === 'cache-first' &&\n                res.outcome === 'partial' &&\n                !reexecutingOperations.has(res.operation.key)));\n          // Set stale to true anyway, even if the reexecute will be blocked, if the operation\n          // is in progress. We can be reasonably sure of that if a layer has been reserved for it.\n          const stale =\n            requestPolicy !== 'cache-only' &&\n            (shouldReexecute ||\n              (res.outcome === 'partial' &&\n                reexecutingOperations.has(res.operation.key) &&\n                hasLayer(store.data, res.operation.key)));\n\n          const result: OperationResult = {\n            operation: addMetadata(res.operation, {\n              cacheOutcome: res.outcome,\n            }),\n            data: res.data,\n            error: res.error,\n            extensions: res.extensions,\n            stale: stale && !res.hasNext,\n            hasNext: shouldReexecute && res.hasNext,\n          };\n\n          if (!shouldReexecute) {\n            /*noop*/\n          } else if (!isBlockedByOptimisticUpdate(res.dependencies)) {\n            client.reexecuteOperation(\n              toRequestPolicy(\n                operations.get(res.operation.key) || res.operation,\n                'network-only'\n              )\n            );\n          } else if (requestPolicy === 'cache-and-network') {\n            requestedRefetch.add(res.operation.key);\n          }\n\n          dispatchDebug({\n            type: 'cacheHit',\n            message: `A requested operation was found and returned from the cache.`,\n            operation: res.operation,\n            data: {\n              value: result,\n            },\n          });\n\n          return result;\n        })\n      );\n\n      // Forward operations that aren't cacheable and rebound operations\n      // Also update the cache with any network results\n      const result$ = pipe(\n        merge([nonCacheOps$, cacheMissOps$]),\n        map(prepareForwardedOperation),\n        forward\n      );\n\n      // Results that can immediately be resolved\n      const nonOptimisticResults$ = pipe(\n        result$,\n        filter(\n          result => !optimisticKeysToDependencies.has(result.operation.key)\n        ),\n        map(result => {\n          const pendingOperations: Operations = new Set();\n          // Update the cache with the incoming API result\n          const cacheResult = updateCacheWithResult(result, pendingOperations);\n          // Execute all dependent queries\n          executePendingOperations(result.operation, pendingOperations, false);\n          return cacheResult;\n        })\n      );\n\n      // Prevent mutations that were previously optimistic from being flushed\n      // immediately and instead clear them out slowly\n      const optimisticMutationCompletion$ = pipe(\n        result$,\n        filter(result =>\n          optimisticKeysToDependencies.has(result.operation.key)\n        ),\n        mergeMap((result: OperationResult): Source<OperationResult> => {\n          const length = mutationResultBuffer.push(result);\n          if (length < optimisticKeysToDependencies.size) {\n            return empty;\n          }\n\n          for (let i = 0; i < mutationResultBuffer.length; i++) {\n            reserveLayer(store.data, mutationResultBuffer[i].operation.key);\n          }\n\n          blockedDependencies.clear();\n\n          const results: OperationResult[] = [];\n          const pendingOperations: Operations = new Set();\n\n          let bufferedResult: OperationResult | void;\n          while ((bufferedResult = mutationResultBuffer.shift()))\n            results.push(\n              updateCacheWithResult(bufferedResult, pendingOperations)\n            );\n\n          // Execute all dependent queries as a single batch\n          executePendingOperations(result.operation, pendingOperations, false);\n\n          return fromArray(results);\n        })\n      );\n\n      return merge([\n        nonOptimisticResults$,\n        optimisticMutationCompletion$,\n        cacheResult$,\n      ]);\n    };\n  };\n","import { pipe, share, merge, makeSubject, filter, onPush } from 'wonka';\n\nimport type {\n  Operation,\n  OperationResult,\n  Exchange,\n  ExchangeIO,\n  CombinedError,\n  RequestPolicy,\n} from '@urql/core';\nimport { stringifyDocument, createRequest, makeOperation } from '@urql/core';\n\nimport type {\n  SerializedRequest,\n  CacheExchangeOpts,\n  StorageAdapter,\n} from './types';\nimport { cacheExchange } from './cacheExchange';\nimport { toRequestPolicy } from './helpers/operation';\n\nconst policyLevel = {\n  'cache-only': 0,\n  'cache-first': 1,\n  'network-only': 2,\n  'cache-and-network': 3,\n} as const;\n\n/** Input parameters for the {@link offlineExchange}.\n * @remarks\n * This configuration object extends the {@link CacheExchangeOpts}\n * as the `offlineExchange` extends the regular {@link cacheExchange}.\n */\nexport interface OfflineExchangeOpts extends CacheExchangeOpts {\n  /** Configures an offline storage adapter for Graphcache.\n   *\n   * @remarks\n   * A {@link StorageAdapter} allows Graphcache to write data to an external,\n   * asynchronous storage, and hydrate data from it when it first loads.\n   * This allows you to preserve normalized data between restarts/reloads.\n   *\n   * @see {@link https://urql.dev/goto/docs/graphcache/offline} for the full Offline Support docs.\n   */\n  storage: StorageAdapter;\n  /** Predicate function to determine whether a {@link CombinedError} hints at a network error.\n   *\n   * @remarks\n   * Not ever {@link CombinedError} means that the device is offline and by default\n   * the `offlineExchange` will check for common network error messages and check\n   * `navigator.onLine`. However, when `isOfflineError` is passed it can replace\n   * the default offline detection.\n   */\n  isOfflineError?(\n    error: undefined | CombinedError,\n    result: OperationResult\n  ): boolean;\n}\n\n/** Exchange factory that creates a normalized cache exchange in Offline Support mode.\n *\n * @param opts - A {@link OfflineExchangeOpts} configuration object.\n * @returns the created normalized, offline cache {@link Exchange}.\n *\n * @remarks\n * The `offlineExchange` is a wrapper around the regular {@link cacheExchange}\n * which adds logic via the {@link OfflineExchangeOpts.storage} adapter to\n * recognize when its offline, when to retry failed mutations, and how\n * to handle longer periods of being offline.\n *\n * @see {@link https://urql.dev/goto/docs/graphcache/offline} for the full Offline Support docs.\n */\nexport const offlineExchange =\n  <C extends OfflineExchangeOpts>(opts: C): Exchange =>\n  input => {\n    const { storage } = opts;\n\n    const isOfflineError =\n      opts.isOfflineError ||\n      ((error: undefined | CombinedError) =>\n        error &&\n        error.networkError &&\n        !error.response &&\n        ((typeof navigator !== 'undefined' && navigator.onLine === false) ||\n          /request failed|failed to fetch|network\\s?error/i.test(\n            error.networkError.message\n          )));\n\n    if (\n      storage &&\n      storage.onOnline &&\n      storage.readMetadata &&\n      storage.writeMetadata\n    ) {\n      const { forward: outerForward, client, dispatchDebug } = input;\n      const { source: reboundOps$, next } = makeSubject<Operation>();\n      const failedQueue: Operation[] = [];\n      let hasRehydrated = false;\n      let isFlushingQueue = false;\n\n      const updateMetadata = () => {\n        if (hasRehydrated) {\n          const requests: SerializedRequest[] = [];\n          for (let i = 0; i < failedQueue.length; i++) {\n            const operation = failedQueue[i];\n            if (operation.kind === 'mutation') {\n              requests.push({\n                query: stringifyDocument(operation.query),\n                variables: operation.variables,\n                extensions: operation.extensions,\n              });\n            }\n          }\n          storage.writeMetadata!(requests);\n        }\n      };\n\n      const filterQueue = (key: number) => {\n        for (let i = failedQueue.length - 1; i >= 0; i--)\n          if (failedQueue[i].key === key) failedQueue.splice(i, 1);\n      };\n\n      const flushQueue = () => {\n        if (!isFlushingQueue) {\n          const sent = new Set<number>();\n          isFlushingQueue = true;\n          for (let i = 0; i < failedQueue.length; i++) {\n            const operation = failedQueue[i];\n            if (operation.kind === 'mutation' || !sent.has(operation.key)) {\n              sent.add(operation.key);\n              if (operation.kind !== 'subscription') {\n                next(makeOperation('teardown', operation));\n                let overridePolicy: RequestPolicy = 'cache-first';\n                for (let i = 0; i < failedQueue.length; i++) {\n                  const { requestPolicy } = failedQueue[i].context;\n                  if (policyLevel[requestPolicy] > policyLevel[overridePolicy])\n                    overridePolicy = requestPolicy;\n                }\n                next(toRequestPolicy(operation, overridePolicy));\n              } else {\n                next(toRequestPolicy(operation, 'cache-first'));\n              }\n            }\n          }\n          isFlushingQueue = false;\n          failedQueue.length = 0;\n          updateMetadata();\n        }\n      };\n\n      const forward: ExchangeIO = ops$ => {\n        return pipe(\n          outerForward(ops$),\n          filter(res => {\n            if (\n              hasRehydrated &&\n              res.operation.kind === 'mutation' &&\n              res.operation.context.optimistic &&\n              isOfflineError(res.error, res)\n            ) {\n              failedQueue.push(res.operation);\n              updateMetadata();\n              return false;\n            }\n\n            return true;\n          }),\n          share\n        );\n      };\n\n      const cacheResults$ = cacheExchange({\n        ...opts,\n        storage: {\n          ...storage,\n          readData() {\n            const hydrate = storage.readData();\n            return {\n              async then(onEntries) {\n                const mutations = await storage.readMetadata!();\n                for (let i = 0; mutations && i < mutations.length; i++) {\n                  failedQueue.push(\n                    client.createRequestOperation(\n                      'mutation',\n                      createRequest(mutations[i].query, mutations[i].variables),\n                      mutations[i].extensions\n                    )\n                  );\n                }\n                onEntries!(await hydrate);\n                storage.onOnline!(flushQueue);\n                hasRehydrated = true;\n                flushQueue();\n              },\n            };\n          },\n        },\n      })({\n        client,\n        dispatchDebug,\n        forward,\n      });\n\n      return operations$ => {\n        const opsAndRebound$ = merge([\n          reboundOps$,\n          pipe(\n            operations$,\n            onPush(operation => {\n              if (operation.kind === 'query' && !hasRehydrated) {\n                failedQueue.push(operation);\n              } else if (operation.kind === 'teardown') {\n                filterQueue(operation.key);\n              }\n            })\n          ),\n        ]);\n\n        return pipe(\n          cacheResults$(opsAndRebound$),\n          filter(res => {\n            if (res.operation.kind === 'query') {\n              if (isOfflineError(res.error, res)) {\n                next(toRequestPolicy(res.operation, 'cache-only'));\n                failedQueue.push(res.operation);\n                return false;\n              } else if (!hasRehydrated) {\n                filterQueue(res.operation.key);\n              }\n            }\n            return true;\n          })\n        );\n      };\n    }\n\n    return cacheExchange(opts)(input);\n  };\n"],"names":["helpUrl","cache","Set","currentDebugStack","popDebugNode","pop","pushDebugNode","typename","node","identifier","kind","Kind","INLINE_FRAGMENT","OPERATION_DEFINITION","name","value","operation","FRAGMENT_DEFINITION","push","getDebugOutput","length","join","invariant","condition","message","code","errorMessage","process","env","NODE_ENV","error","Error","warn","logger","has","console","add","EMPTY_DIRECTIVES","getDirectives","_directives","getName","getFragmentTypeName","typeCondition","getFieldAlias","alias","emptySelectionSet","getSelectionSet","selectionSet","selections","getTypeCondition","getFieldArguments","vars","args","arguments","i","l","arg","valueFromASTUntyped","undefined","filterVariables","input","variableDefinitions","variable","normalizeVariables","def","defaultValue","key","getMainOperation","doc","definitions","getFragments","fragments","shouldInclude","directives","include","skip","directive","isDeferred","defer","argument","isOptional","optional","required","buildClientSchema","__schema","typemap","Map","buildNameMap","arr","map","buildType","type","interfaces","fields","field","types","possibleTypes","schema","query","queryType","mutation","mutationType","subscription","subscriptionType","isSubType","abstract","possible","abstractType","get","possibleType","out","set","BUILTIN_NAME","isFieldNullable","fieldName","getField","isListNullable","ofType","isFieldAvailableOnType","indexOf","isInterfaceOfType","expectAbstractType","expectObjectType","object","expectValidKeyingConfig","keys","expectValidUpdatesConfig","updates","addition","warnAboutResolver","warnAboutAbstractResolver","expectValidResolversConfig","resolvers","validQueries","resolverQuery","Query","validTypeProperties","resolverProperty","expectValidOptimisticMutationsConfig","optimisticMutations","validMutations","keyOfField","stringifyVariables","joinKeys","parentKey","fieldInfoOfKey","fieldKey","parenIndex","slice","JSON","parse","serializeKeys","entityKey","replace","deserializeKeyInfo","dotIndex","currentOwnership","currentDataMapping","currentData","currentOptimisticKey","currentOperation","currentDependencies","currentForeignData","currentOptimistic","makeData","data","isArray","newData","ownsData","initDataState","operationType","layerKey","isOptimistic","isForeignData","WeakSet","WeakMap","hydrating","optimisticOrder","commutativeKeys","reserveLayer","splice","delete","createLayer","deleteLayer","clearDataState","getCurrentDependencies","dirtyKeys","squashLayer","storage","setTimeout","gc","persistData","noopDataState","deferredKeys","DEFAULT_EMPTY_SET","make","queryRootKey","persist","refCount","links","optimistic","base","abstractToConcreteMap","records","setNode","keymap","entity","Object","create","getNode","getRefCount","updateRCForEntity","by","count","newCount","updateRCForLink","link","Array","extractNodeFields","fieldInfos","seenFieldKeys","extractNodeMapFields","rc","record","__typename","linkNode","updateDependencies","updatePersist","readRecord","readLink","getEntitiesForType","writeType","existingTypes","typeSet","getConcreteTypes","isSeenConcreteType","writeConcreteType","concreteType","writeRecord","existing","isEqualLinkOrScalar","hasField","writeLink","entityLinks","hasNext","index","clearLayer","hasLayer","unshift","previousDependencies","entry","entries","keyMap","inspectFields","x","writeData","clear","hydrateData","a","b","some","el","contextRef","deferRef","optionalRef","getFieldError","ctx","__internal","path","errorMap","makeContext","store","variables","parent","parentTypeName","parentFieldKey","partial","graphQLErrors","graphQLError","updateContext","isFragmentHeuristicallyMatching","FIELD","makeSelectionIterator","_defer","_optional","child","next","select","fragment","isMatching","isFragmentMatching","isFragmentOptional","_generated","isProbableAbstractType","size","ensureData","ensureLink","ref","keyOfEntity","_query","request","formatDocument","rootKey","rootFields","rootSelect","readRoot","InMemoryData","readSelection","dependencies","rootNames","iterate","hasChanged","output","fieldAlias","fieldValue","dataFieldValue","readRootField","originalData","_queryFragment","fragmentName","names","result","getFieldResolver","fieldResolver","directiveResolver","directiveNode","isQuery","hasFields","hasPartials","fieldArgs","resolver","resultValue","resolveResolverResult","resolveLink","stringify","prevData","isOwnedData","_isListNullable","childResult","isDataOrKey","newLink","childLink","invalidateEntity","invalidateType","excludedEntities","includes","_write","writeSelection","_writeFragment","dataToWrite","rootField","isRoot","expected","writeField","updater","resolved","KEYLESS_TYPE_RE","prevLink","indexKey","prevIndex","test","childKey","Store","constructor","opts","globalIDs","queryName","mutationName","subscriptionName","id","_id","globalID","resolve","fieldLink","invalidate","shouldInvalidateType","updateQuery","createRequest","readQuery","readFragment","writeFragment","rest","addMetadata","meta","makeOperation","context","toRequestPolicy","requestPolicy","cacheExchange","forward","client","dispatchDebug","readData","then","onCacheHydrated","optimisticKeysToDependencies","mutationResultBuffer","operations","results","blockedDependencies","requestedRefetch","deps","reexecutingOperations","dependentOperations","isBlockedByOptimisticUpdate","dep","values","collectPendingOperations","pendingOperations","executePendingOperations","op","policy","reexecuteOperation","_reexecutingOperations","prepareForwardedOperation","depOps","operationResultFromCache","cacheOutcome","outcome","updateCacheWithResult","queryDependencies","writeDependencies","queryResult","extensions","stale","operations$","cacheOps$","share","filter","nonCacheOps$","cacheMissOps$","res","cacheResult$","shouldReexecute","result$","merge","nonOptimisticResults$","cacheResult","optimisticMutationCompletion$","mergeMap","empty","bufferedResult","shift","fromArray","policyLevel","offlineExchange","isOfflineError","networkError","response","navigator","onLine","onOnline","readMetadata","writeMetadata","outerForward","source","reboundOps$","makeSubject","failedQueue","hasRehydrated","isFlushingQueue","updateMetadata","requests","stringifyDocument","filterQueue","flushQueue","sent","overridePolicy","ops$","cacheResults$","hydrate","onEntries","mutations","createRequestOperation","opsAndRebound$","onPush"],"mappings":"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"}